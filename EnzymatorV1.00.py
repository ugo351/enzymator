#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
EnzymatorV1.00 - MALDI-MS Peptide Analysis Tool

Copyright (c) 2025 Ugo PASCO
Licensed under the MIT License - see LICENSE file for details
"""
from csv import writer
import tkinter as tk
from tkinter import messagebox, filedialog, simpledialog, ttk
import pandas as pd
import os
import threading
import re
import time
from collections import Counter, defaultdict
from functools import lru_cache
from dataclasses import dataclass, field
from typing import Dict, Optional
import matplotlib.pyplot as plt

# =============================================================================
# 1. CONSTANTS AND DATA STRUCTURES
# =============================================================================

amino_acids_masses = {
    'A': 71.037114,'R': 156.101111,'N': 114.042927,'D': 115.026943,'C': 103.009185,'Q': 128.058578,
    'E': 129.042593,'G': 57.021464,'H': 137.058912,'I': 113.084064,'L': 113.084064,'K': 128.094963,
    'M': 131.040485,'F': 147.068414,'P': 97.052764,'S': 87.032028, 'T': 101.047679,'W': 186.079313, 
    'Y': 163.06332,'V': 99.068414,}

immonium_ions_masses = {
    'A': [44.0495],'R': [129.1136],'N': [73.0280], 'D': [74.0363],'C': [76.0221],'E': [88.0399],
    'Q': [87.0553],'G': [30.034],'H': [82.0534],'I': [86.0969],'L': [86.0969],'K': [101.1079, 84.0808],  
    'S': [60.0444],'T': [74.0600],'W': [159.0922],'Y': [136.0762], 'V': [72.0813]}

mass_H = 1.007825
mass_O = 15.994915
mass_N = 14.003074
mass_C = 12.000000
mass_proton = 1.007276

# Sequences 
seq_hMMP1 = "MHSFPPLLLLLFWGVVSHSFPATLETQEQDVDLVQKYLEKYYNLKNDGRQVEKRRNSGPVVEKLKQMQEFFGLKVTGKPDAETLKVMKQPRCGVPDVAQFVLTEGNPRWEQTHLTYRIENYTPDLPRADVDHAIEKAFQLWSNVTPLTFTKVSEGQADIMISFVRGDHRDNSPFDGPGGNLAHAFQPGPGIGGDAHFDEDERWTNNFREYNLHRVAAHELGHSLGLSHSTDIGALMYPSYTFSGDVQLAQDDIDGIQAIYGRSQNPVQPIGPQTPKACDSKLTFDAITTIRGEVMFFKDRFYMRTNPFYPEVELNFISVFWPQLPNGLEAAYEFADRDEVRFFKGNKYWAVQGQNVLHGYPKDIYSSFGFPRTVKHIDAALSEENTGKTYFFVANKYWRYDEYKRSMDPGYPKMIAHDFPGIGHKVDAVFMKDGFFYFFHGTRQYKFDPKTKRILTLQKANSWFNCRKN"
seq_hMMP2 = "MEALMARGALTGPLRALCLLGCLLSHAAAAPSPIIKFPGDVAPKTDKELAVQYLNTFYGCPKESCNLFVLKDTLKKMQKFFGLPQTGDLDQNTIETMRKPRCGNPDVANYNFFPRKPKWDKNQITYRIIGYTPDLDPETVDDAFARAFQVWSDVTPLRFSRIHDGEADIMINFGRWEHGDGYPFDGKDGLLAHAFAPGTGVGGDSHFDDDELWTLGEGQVVRVKYGNADGEYCKFPFLFNGKEYNSCTDTGRSDGFLWCSTTYNFEKDGKYGFCPHEALFTMGGNAEGQPCKFPFRFQGTSYDSCTTEGRTDGYRWCGTTEDYDRDKKYGFCPETAMSTVGGNSEGAPCVFPFTFLGNKYESCTSAGRSDGKMWCATTANYDDDRKWGFCPDQGYSLFLVAAHEFGHAMGLEHSQDPGALMAPIYTYTKNFRLSQDDIKGIQELYGASPDIDLGTGPTPTLGPVTPEICKQDIVFDGIAQIRGEIFFFKDRFIWRTVTPRDKPMGPLLVATFWPELPEKIDAVYEAPQEEKAVFFAGNEYWIYSASTLERGYPKPLTSLGLPPDVQRVDAAFNWSKNKKTYIFAGDKFWRYNEVKKKMDPGFPKLIADAWNAIPDNLDAVVDLQGGGHSYFFKGAYYLKLENQSLKSVKFGSIKSDWLGC"
seq_hMMP3 = "MKSLPILLLLCVAVCSAYPLDGAARGEDTSMNLVQKYLENYYDLKKDVKQFVRRKDSGPVVKKIREMQKFLGLEVTGKLDSDTLEVMRKPRCGVPDVGHFRTFPGIPKWRKTHLTYRIVNYTPDLPKDAVDSAVEKALKVWEEVTPLTFSRLYEGEADIMISFAVREHGDFYPFDGPGNVLAHAYAPGPGINGDAHFDDDEQWTKDTTGTNLFLVAAHEIGHSLGLFHSANTEALMYPLYHSLTDLTRFRLSQDDINGIQSLYGPPPDSPETPLVPTEPVPPEPGTPANCDPALSFDAVSTLRGEILIFKDRHFWRKSLRKLEPELHLISSFWPSLPSGVDAAYEVTSKDLVFIFKGNQFWAIRGNEVRAGYPRGIHTLGFPPTVRKIDAAISDKEKNKTYFFVEDKYWRFDEKRNSMEPGFPKQIAEDFPGIDSKIDAVFEEFGFFYFFTGSSQLEFDPNAKKVTHTLKSNSWLNC"
seq_hMMP7 = "MRLTVLCAVCLLPGSLALPLPQEAGGMSELQWEQAQDYLKRFYLYDSETKNANSLEAKLKEMQKFFGLPITGMLNSRVIEIMQKPRCGVPDVAEYSLFPNSPKWTSKVVTYRIVSYTRDLPHITVDRLVSKALNMWGKEIPLHFRKVVWGTADIMIGFARGAHGDSYPFDGPGNTLAHAFAPGTGLGGDAHFDEDERWTDGSSLGINFLYAATHELGHSLGMGHSSDPNAVMYPTYGNGDPQNFKLSQDDIKGIQKLYGKRSNSRKK"
seq_hMMP8 = 'MFSLKTLPFLLLLHVQISKAFPVSSKEKNTKTVQDYLEKFYQLPSNQYQSTRKNGTNVIVEKLKEMQRFFGLNVTGKPNEETLDMMKKPRCGVPDSGGFMLTPGNPKWERTNLTYRIRNYTPQLSEAEVERAIKDAFELWSVASPLIFTRISQGEADINIAFYQRDHGDNSPFDGPNGILAHAFQPGQGIGGDAHFDAEETWTNTSANYNLFLVAAHEFGHSLGLAHSSDPGALMYPNYAFRETSNYSLPQDDIDGIQAIYGLSSNPIQPTGPSTPKPCDPSLTFDAITTLRGEILFFKDRYFWRRHPQLQRVEMNFISLFWPSLPTGIQAAYEDFDRDLIFLFKGNQYWALSGYDILQGYPKDISNYGFPSSVQAIDAAVFYRSKTYFFVNDQFWRYDNQRQFMEPGYPKSISGAFPGIESKVDAVFQQEHFFHVFSGPRYYAFDLIAQRVTRVARGNKWLNCRYG'
seq_hMMP9 = "MSLWQPLVLVLLVLGCCFAAPRQRQSTLVLFPGDLRTNLTDRQLAEEYLYRYGYTRVAEMRGESKSLGPALLLLQKQLSLPETGELDSATLKAMRTPRCGVPDLGRFQTFEGDLKWHHHNITYWIQNYSEDLPRAVIDDAFARAFALWSAVTPLTFTRVYSRDADIVIQFGVAEHGDGYPFDGKDGLLAHAFPPGPGIQGDAHFDDDELWSLGKGVVVPTRFGNADGAACHFPFIFEGRSYSACTTDGRSDGLPWCSTTANYDTDDRFGFCPSERLYTQDGNADGKPCQFPFIFQGQSYSACTTDGRSDGYRWCATTANYDRDKLFGFCPTRADSTVMGGNSAGELCVFPFTFLGKEYSTCTSEGRGDGRLWCATTSNFDSDKKWGFCPDQGYSLFLVAAHEFGHALGLDHSSVPEALMYPMYRFTEGPPLHKDDVNGIRHLYGPRPEPEPRPPTTTTPQPTAPPTVCPTGPPTVHPSERPTAGPTGPPSAGPTGPPTAGPSTATTVPLSPVDDACNVNIFDAIAEIGNQLYLFKDGKYWRFSEGRGSRPQGPFLIADKWPALPRKLDSVFEERLSKKLFFFSGRQVWVYTGASVLGPRRLDKLGLGADVAQVTGALRSGRGKMLLFSGRRLWRFDVKAQMVDPRSASEVDRMFPGVPLDTHDVFQYREKAYFCQDRFYWRVSSRSELNQVDQVGYVTYDILQCPED"
seq_hMMP10 = 'MMHLAFLVLLCLPVCSAYPLSGAAKEEDSNKDLAQQYLEKYYNLEKDVKQFRRKDSNLIVKKIQGMQKFLGLEVTGKLDTDTLEVMRKPRCGVPDVGHFSSFPGMPKWRKTHLTYRIVNYTPDLPRDAVDSAIEKALKVWEEVTPLTFSRLYEGEADIMISFAVKEHGDFYSFDGPGHSLAHAYPPGPGLYGDIHFDDDEKWTEDASGTNLFLVAAHELGHSLGLFHSANTEALMYPLYNSFTELAQFRLSQDDVNGIQSLYGPPPASTEEPLVPTKSVPSGSEMPAKCDPALSFDAISTLRGEYLFFKDRYFWRRSHWNPEPEFHLISAFWPSLPSYLDAAYEVNSRDTVFIFKGNEFWAIRGNEVQAGYPRGIHTLGFPPTIRKIDAAVSDKEKKKTYFFAADKYWRFDENSQSMEQGFPRLIADDFPGVEPKVDAVLQAFGFFYFFSGSSQFEFDPNARMVTHILKSNSWLHC'
seq_hMMP11 = 'MAPAAWLRSAAARALLPPMLLLLLQPPPLLARALPPDAHHLHAERRGPQPWHAALPSSPAPAPATQEAPRPASSLRPPRCGVPDPSDGLSARNRQKRFVLSGGRWEKTDLTYRILRFPWQLVQEQVRQTMAEALKVWSDVTPLTFTEVHEGRADIMIDFARYWHGDDLPFDGPGGILAHAFFPKTHREGDVHFDYDETWTIGDDQGTDLLQVAAHEFGHVLGLQHTTAAKALMSAFYTFRYPLSLSPDDCRGVQHLYGQPWPTVTSRTPALGPQAGIDTNEIAPLEPDAPPDACEASFDAVSTIRGELFFFKAGFVWRLRGGQLQPGYPALASRHWQGLPSPVDAAFEDAQGHIWFFQGAQYWVYDGEKPVLGPAPLTELGLVRFPVHAALVWGPEKNKIYFFRGRDYWRFHPSTRRVDSPVPRRATDWRGVPSEIDAAFQDADGYAYFLRGRLYWKFDPVKVKALEGFPRLVGPDFFGCAEPANTFL'
seq_mMMP12 = "MSCTLLKGVCTMKFLMMIVFLQVSACGAAPMNDSEFAEWYLSRFYDYGKDRIPMTKTKTNRNFLKEKLQEMQQFFGLEATGQLDNSTLAIMHIPRCGVPDVQHLRAVPQRSRWMKRYLTYRIYNYTPDMKREDVDYIFQKAFQVWSDVTPLRFRKLHKDEADIMILFAFGAHGDFNYFDGKGGTLAHAFYPGPGIQGDAHFDEAETWTKSFQGTNLFLVAVHELGHSLGLQHSNNPKSIMYPTYRYLNPSTFRLSADDIRNIQSLYGAPVKPPSLTKPSSPPSTFCHQSLSFDAVTTVGEKIFFFKDWFFWWKLPGSPATNITSISSIWPSIPSGIQAAYEIESRNQLFLFKDEKYWLINNLVPEPHYPRSIYSLGFSASVKKVDAAVFDPLRQKVYFFVDKHYWRYDVRQELMDPAYPKLISTHFPGIKPKIDAVLYFKRHYYIFQGAYQLEYDPLFRRVTKTLKSTSWFGC"
seq_hMMP12 = "MKFLLILLLQATASGALPLNSSTSLEKNNVLFGERYLEKFYGLEINKLPVTKMKYSGNLMKEKIQEMQHFLGLKVTGQLDTSTLEMMHAPRCGVPDVHHFREMPGGPVWRKHYITYRINNYTPDMNREDVDYAIRKAFQVWSNVTPLKFSKINTGMADILVVFARGAHGDFHAFDGKGGILAHAFGPGSGIGGDAHFDEDEFWTTHSGGTNLFLTAVHEIGHSLGLGHSSDPKAVMFPTYKYVDINTFRLSADDIRGIQSLYGDPKENQRLPNPDNSEPALCDPNLSFDAVTTVGNKIFFFKDRFFWLKVSERPKTSVNLISSLWPTLPSGIEAAYEIEARNQVFLFKDDKYWLISNLRPEPNYPKSIHSFGFPNFVKKIDAAVFNPRFYRTYFFVDNQYWRYDERRQMMDPGYPKLITKNFQGIGPKIDAVFYSKNKYYYFFQGSNQFEYDFLLQRITKTLKSNSWFGC"
seq_hMMP13 = "MHPGVLAAFLFLSWTHCRALPLPSGGDEDDLSEEDLQFAERYLRSYYHPTNLAGILKENAASSMTERLREMQSFFGLEVTGKLDDNTLDVMKKPRCGVPDVGEYNVFPRTLKWSKMNLTYRIVNYTPDMTHSEVEKAFKKAFKVWSDVTPLNFTRLHDGIADIMISFGIKEHGDFYPFDGPSGLLAHAFPPGPNYGGDAHFDDDETWTSSSKGYNLFLVAAHEFGHSLGLDHSKDPGALMFPIYTYTGKSHFMLPDDDVQGIQSLYGPGDEDPNPKHPKTPDKCDPSLSLDAITSLRGETMIFKDRFFWRLHPQQVDAELFLTKSFWPELPNRIDAAYEHPSHDLIFIFRGRKFWALNGYDILEGYPKKISELGLPKEVKKISAAVHFEDTGKTLLFSGNQVWRYDDTNHIMDKDYPRLIEEDFPGIGDKVDAVYEKNGYIYFFNGPIQFEYSIWSNRIVRVMPANSILWC"
seq_MT_hMMP14 = "MSPAPRPPRCLLLPLLTLGTALASLGSAQSSSFSPEAWLQQYGYLPPGDLRTHTQRSPQSLSAAIAAMQKFYGLQVTGKADADTMKAMRRPRCGVPDKFGAEIKANVRRKRYAIQGLKWQHNEITFCIQNYTPKVGEYATYEAIRKAFRVWESATPLRFREVPYAYIREGHEKQADIMIFFAEGFHGDSTPFDGEGGFLAHAYFPGPNIGGDTHFDSAEPWTVRNEDLNGNDIFLVAVHELGHALGLEHSSDPSAIMAPFYQWMDTENFVLPDDDRRGIQQLYGGESGFPTKMPPQPRTTSRPSVPDKPKNPTYGPNICDGNFDTVAMLRGEMFVFKERWFWRVRNNQVMDGYPMPIGQFWRGLPASINTAYERKDGKFVFFKGDKHWVFDEASLEPGYPKHIKELGRGLPTDKIDAALFWMPNGKTYFFRGNKYYRFNEELRAVDSEYPKNIKVWEGIPESPRGSFMGSDEVFTYFYKGNKYWKFNNQKLKVEPGYPKSALRDWMGCPSGGRPDEGTEEETEVIIIEVDEEGGGAVSAAAVVLPVLLLLLVLAVGLAVFFFRRHGTPRRLLYCQRSLLDKV"
seq_MT_hMMP15 = "MGSDPSAPGRPGWTGSLLGDREEAARPRLLPLLLVLLGCLGLGVAAEDAEVHAENWLRLYGYLPQPSRHMSTMRSAQILASALAEMQRFYGIPVTGVLDEETKEWMKRPRCGVPDQFGVRVKANLRRRRKRYALTGRKWNNHHLTFSIQNYTEKLGWYHSMEAVRRAFRVWEQATPLVFQEVPYEDIRLRRQKEADIMVLFASGFHGDSSPFDGTGGFLAHAYFPGPGLGGDTHFDADEPWTFSSTDLHGNNLFLVAVHELGHALGLEHSSNPNAIMAPFYQWKDVDNFKLPEDDLRGIQQLYGTPDGQPQPTQPLPTVTPRRPGRPDHRPPRPPQPPPPGGKPERPPKPGPPVQPRATERPDQYGPNICDGDFDTVAMLRGEMFVFKGRWFWRVRHNRVLDNYPMPIGHFWRGLPGDISAAYERQDGRFVFFKGDRYWLFREANLEPGYPQPLTSYGLGIPYDRIDTAIWWEPTGHTFFFQEDRYWRFNEETQRGDPGYPKPISVWQGIPASPKGAFLSNDAAYTYFYKGTKYWKFDNERLRMEPGYPKSILRDFMGCQEHVEPGPRWPDVARPPFNPHGGAEPGADSAEGDVGDGDGDFGAGVNKDGGSRVVVQMEEVARTVNVVMVLVPLLLLLCVLGLTYALVQMQRKGAPRVLLYCKRSLQEWV"
seq_MT_hMMP16 = "MILLTFSTGRRLDFVHHSGVFFLQTLLWILCATVCGTEQYFNVEVWLQKYGYLPPTDPRMSVLRSAETMQSALAAMQQFYGINMTGKVDRNTIDWMKKPRCGVPDQTRGSSKFHIRRKRYALTGQKWQHKHITYSIKNVTPKVGDPETRKAIRRAFDVWQNVTPLTFEEVPYSELENGKRDVDITIIFASGFHGDSSPFDGEGGFLAHAYFPGPGIGGDTHFDSDEPWTLGNPNHDGNDLFLVAVHELGHALGLEHSNDPTAIMAPFYQYMETDNFKLPNDDLQGIQKIYGPPDKIPPPTRPLPTVPPHRSIPPADPRKNDRPKPPRPPTGRPSYPGAKPNICDGNFNTLAILRREMFVFKDQWFWRVRNNRVMDGYPMQITYFWRGLPPSIDAVYENSDGNFVFFKGNKYWVFKDTTLQPGYPHDLITLGSGIPPHGIDSAIWWEDVGKTYFFKGDRYWRYSEEMKTMDPGYPKPITVWKGIPESPQGAFVHKENGFTYFYKGKEYWKFNNQILKVEPGYPRSILKDFMGCDGPTDRVKEGHSPPDDVDIVIKLDNTASTVKAIAIVIPCILALCLLVLVYTVFQFKRKGTPRHILYCKRSMQEWV"
seq_MT_hMMP17 = "MRRRAARGPGPPPPGPGLSRLPLPLLLLLALGTRGGCAAPAPAPRAEDLSLGVEWLSRFGYLPPADPTTGQLQTQEELSKAITAMQQFGGLEATGILDEATLALMKTPRCSLPDLPVLTQARRRRQAPAPTKWNKRNLSWRVRTFPRDSPLGHDTVRALMYYALKVWSDIAPLNFHEVAGSAADIQIDFSKADHNDGYPFDGPGGTVAHAFFPGHHHTAGDTHFDDDEAWTFRSSDAHGMDLFAVAVHEFGHAIGLSHVAAAHSIMRPYYQGPVGDPLRYGLPYEDKVRVWQLYGVRESVSPTAQPEEPPLLPEPPDNRSSAPPRKDVPHRCSTHFDAVAQIRGEAFFFKGKYFWRLTRDRHLVSLQPAQMHRFWRGLPLHLDSVDAVYERTSDHKIVFFKGDRYWVFKDNNVEEGYPRPVSDFSLPPGGIDAAFSWAHNDRTYFFKDQLYWRYDDHTRHMDPGYPAQSPLWRGVPSTLDDAMRWSDGASYFFRGQEYWKVLDGELEVAPGYPQSTARDWLVCGDSQADGSVAAGVDAAEGPRAPPGQHDQSRSEDGYEVCSCTSGASSPPGAPGPLVAATMLLLLPPLSPGALWTAAQALTL"
seq_hMMP19 = "MNCQQLWLGFLLPMTVSGRVLGLAEVAPVDYLSQYGYLQKPLEGSNNFKPEDITEALRAFQEASELPVSGQLDDATRARMRQPRCGLEDPFNQKTLKYLLLGRWRKKHLTFRILNLPSTLPPHTARAALRQAFQDWSNVAPLTFQEVQAGAADIRLSFHGRQSSYCSNTFDGPGRVLAHADIPELGSVHFDEDEFWTEGTYRGVNLRIIAAHEVGHALGLGHSRYSQALMAPVYEGYRPHFKLHPDDVAGIQALYGKKSPVIRDEEEEETELPTVPPVPTEPSPMPDPCSSELDAMMLGPRGKTYAFKGDYVWTVSDSGPGPLFRVSALWEGLPGNLDAAVYSPRTQWIHFFKGDKVWRYINFKMSPGFPKKLNRVEPNLDAALYWPLNQKVFLFKGSGYWQWDELARTDFSSYPKPIKGLFTGVPNQPSAAMSWQDGRVYFFKGKVYWRLNQQLRVEKGYPRNISHNWMHCRPRTIDTTPSGGNTTPSGTGITLDTTLSATETTFEY"
seq_hMMP20 = "MKVLPASGLAVFLIMALKFSTAAPSLVAASPRTWRNNYRLAQAYLDKYYTNKEGHQIGEMVARGSNSMIRKIKELQAFFGLQVTGKLDQTTMNVIKKPRCGVPDVANYRLFPGEPKWKKNTLTYRISKYTPSMSSVEVDKAVEMALQAWSSAVPLSFVRINSGEADIMISFENGDHGDSYPFDGPRGTLAHAFAPGEGLGGDTHFDNAEKWTMGTNGFNLFTVAAHEFGHALGLAHSTDPSALMYPTYKYKNPYGFHLPKDDVKGIQALYGPRKVFLGKPTLPHAPHHKPSIPDLCDSSSSFDAVTMLGKELLLFKDRIFWRRQVHLRTGIRPSTITSSFPQLMSNVDAAYEVAERGTAYFFKGPHYWITRGFQMQGPPRTIYDFGFPRHVQQIDAAVYLREPQKTLFFVGDEYYSYDERKRKMEKDYPKNTEEEFSGVNGQIDAAVELNGYIYFFSGPKTYKYDTEKEDVVSVVKSSSWIGC"
seq_hMMP21 = "MLAASIFRPTLLLCWLAAPWPTQPESLFHSRDRSDLEPSPLRQAKPIADLHAAQRFLSRYGWSGVWAAWGPSPEGPPETPKGAALAEAVRRFQRANALPASGELDAATLAAMNRPRCGVPDMRPPPPSAPPSPPGPPPRARSRRSPRAPLSLSRRGWQPRGYPDGGAAQAFSKRTLSWRLLGEALSSQLSVADQRRIVALAFRMWSEVTPLDFREDLAAPGAAVDIKLGFGRGRHLGCPRAFDGSGQEFAHAWRLGDIHFDDDEHFTPPTSDTGISLLKVAVHEIGHVLGLPHTYRTGSIMQPNYIPQEPAFELDWSDRKAIQKLYGSCEGSFDTAFDWIRKERNQYGEVMVRFSTYFFRNSWYWLYENRNNRTRYGDPIQILTGWPGIPTHNIDAFVHIWTWKRDERYFFQGNQYWRYDSDKDQALTEDEQGKSYPKLISEGFPGIPSPLDTAFYDRRQKLIYFFKESLVFAFDVNRNRVLNSYPKRITEVFPAVIPQNHPFRNIDSAYYSYAYNSIFFFKGNAYWKVVNDKDKQQNSWLPANGLFPKKFISEKWFDVCDVHISTLNM"
seq_hMMP23 = "MGRGARVPSEAPGAGVERRWLGAALVALCLLPALVLLARLGAPAVPAWSAAQGDVAALGLSAVPPTRVPGPLAPRRRRYTLTPARLRWDHFNLTYRILSFPRNLLSPRETRRALAAAFRMWSDVSPFSFREVAPEQPSDLRIGFYPINHTDCLVSALHHCFDGPTGELAHAFFPPHGGIHFDDSEYWVLGPTRYSWKKGVWLTDLVHVAAHEIGHALGLMHSQHGRALMHLNATLRGWKALSQDELWGLHRLYGCLDRLFVCASWARRGFCDARRRLMKRLCPSSCDFCYEFPFPTVATTPPPPRTKTRLVPEGRNVTFRCGQKILHKKGKVYWYKDQEPLEFSYPGYLALGEAHLSIIANAVNEGTYTCVVRRQQRVLTTYSWRVRVRG"
seq_MT_hMMP24 = "MPRSRGGRAAPGPPPPPPPPGQAPRWSRWRVPGRLLLLLLPALCCLPGAARAAAAAAGAGNRAAVAVAVARADEAEAPFAGQNWLKSYGYLLPYDSRASALHSAKALQSAVSTMQQFYGIPVTGVLDQTTIEWMKKPRCGVPDHPHLSRRRRNKRYALTGQKWRQKHITYSIHNYTPKVGELDTRKAIRQAFDVWQKVTPLTFEEVPYHEIKSDRKEADIMIFFASGFHGDSSPFDGEGGFLAHAYFPGPGIGGDTHFDSDEPWTLGNANHDGNDLFLVAVHELGHALGLEHSSDPSAIMAPFYQYMETHNFKLPQDDLQGIQKIYGPPAEPLEPTRPLPTLPVRRIHSPSERKHERQPRPPRPPLGDRPSTPGTKPNICDGNFNTVALFRGEMFVFKDRWFWRLRNNRVQEGYPMQIEQFWKGLPARIDAAYERADGRFVFFKGDKYWVFKEVTVEPGYPHSLGELGSCLPREGIDTALRWEPVGKTYFFKGERYWRYSEERRATDPGYPKPITVWKGIPQAPQGAFISKEGYYTYFYKGRDYWKFDNQKLSVEPGYPRNILRDWMGCNQKEVERRKERRLPQDDVDIMVTINDVPGSVNAVAVVIPCILSLCILVLVYTIFQFKNKTGPQPVTYYKRPVQEWV"
seq_hMMP25 = "MRLRLRLLALLLLLLAPPARAPKPSAQDVSLGVDWLTRYGYLPPPHPAQAQLQSPEKLRDAIKVMQRFAGLPETGRMDPGTVATMRKPRCSLPDVLGVAGLVRRRRRYALSGSVWKKRTLTWRVRSFPQSSQLSQETVRVLMSYALMAWGMESGLTFHEVDSPQGQEPDILIDFARAFHQDSYPFDGLGGTLAHAFFPGEHPISGDTHFDDEETWTFGSKDGEGTDLFAVAVHEFGHALGLGHSSAPNSIMRPFYQGPVGDPDKYRLSQDDRDGLQQLYGKAPQTPYDKPTRKPLAPPPQPPASPTHSPSFPIPDRCEGNFDAIANIRGETFFFKGPWFWRLQPSGQLVSPRPARLHRFWEGLPAQVRVVQAAYARHRDGRILLFSGPQFWVFQDRQLEGGARPLTELGLPPGEEVDAVFSWPQNGKTYLVRGRQYWRYDEAAARPDPGYPRDLSLWEGAPPSPDDVTVSNAGDTYFFKGAHYWRFPKNSIKTEPDAPQPMGPNWLDCPAPSSGPRAPRPPKATPVSETCDCQCELNQAAGRWPAPIPLLLLPLLVGGVA"
seq_hMMP26 = "MQLVILRVTIFLPWCFAVPVPPAADHKGWDFVEGYFHQFFLTKKESPLLTQETQTQLLQQFHRNGTDLLDMQMHALLHQPHCGVPDGSDTSISPGRCKWNKHTLTYRIINYPHDMKPSAVKDSIYNAVSIWSNVTPLIFQQVQNGDADIKVSFWQWAHEDGWPFDGPGGILGHAFLPNSGNPGVVHFDKNEHWSASDTGYNLFLVATHEIGHSLGLQHSGNQSSIMYPTYWYHDPRTFQLSADDIQRIQHLYGEKCSSDIP"
seq_hMMP27 = "MKRLLLLFLFFITFSSAFPLVRMTENEENMQLAQAYLNQFYSLEIEGNHLVQSKNRSLIDDKIREMQAFFGLTVTGKLDSNTLEIMKTPRCGVPDVGQYGYTLPGWRKYNLTYRIINYTPDMARAAVDEAIQEGLEVWSKVTPLKFTKISKGIADIMIAFRTRVHGRCPRYFDGPLGVLGHAFPPGPGLGGDTHFDEDENWTKDGAGFNLFLVAAHEFGHALGLSHSNDQTALMFPNYVSLDPRKYPLSQDDINGIQSIYGGLPKEPAKPKEPTIPHACDPDLTFDAITTFRREVMFFKGRHLWRIYYDITDVEFELIASFWPSLPADLQAAYENPRDKILVFKDENFWMIRGYAVLPDYPKSIHTLGFPGRVKKIDAAVCDKTTRKTYFFVGIWCWRFDEMTQTMDKGFPQRVVKHFPGISIRVDAAFQYKGFFFFSRGSKQFEYDIKTKNITRIMRTNTWFQCKEPKNSSFGFDINKEKAHSGGIKILYHKSLSLFIFGIVHLLKNTSIYQ"
seq_hMMP28 = "MVARVGLLLRALQLLLWGHLDAQPAERGGQELRKEAEAFLEKYGYLNEQVPKAPTSTRFSDAIRAFQWVSQLPVSGVLDRATLRQMTRPRCGVTDTNSYAAWAERISDLFARHRTKMRRKKRFAKQGNKWYKQHLSYRLVNWPEHLPEPAVRGAVRAAFQLWSNVSALEFWEAPATGPADIRLTFFQGDHNDGLGNAFDGPGGALAHAFLPRRGEAHFDQDERWSLSRRRGRNLFVVLAHEIGHTLGLTHSPAPRALMAPYYKRLGRDALLSWDDVLAVQSLYGKPLGGSVAVQLPGKLFTDFETWDSYSPQGRRPETQGPKYCHSSFDAITVDRQQQLYIFKGSHFWEVAADGNVSEPRPLQERWVGLPPNIEAAAVSLNDGDFYFFKGGRCWRFRGPKPVWGLPQLCRAGGLPRHPDAALFFPPLRRLILFKGARYYVLARGGLQVEPYYPRSLQDWGGIPEEVSGALPRPDGSIIFFRDDRYWRLDQAKLQATTSGRWATELPWMGCWHANSGSALF"
seq_HSA = "MKWVTFISLLFLFSSAYSRGVFRRDAHKSEVAHRFKDLGEENFKALVLIAFAQYLQQCPFEDHVKLVNEVTEFAKTCVADESAENCDKSLHTLFGDKLCTVATLRETYGEMADCCAKQEPERNECFLQHKDDNPNLPRLVRPEVDVMCTAFHDNEETFLKKYLYEIARRHPYFYAPELLFFAKRYKAAFTECCQAADKAACLLPKLDELRDEGKASSAKQRLKCASLQKFGERAFKAWAVARLSQRFPKAEFAEVSKLVTDLTKVHTECCHGDLLECADDRADLAKYICENQDSISSKLKECCEKPLLEKSHCIAEVENDEMPADLPSLAADFVESKDVCKNYAEAKDVFLGMFLYEYARRHPDYSVVLLLRLAKTYETTLEKCCAAADPHECYAKVFDEFKPLVEEPQNLIKQNCELFEQLGEYKFQNALLVRYTKKVPQVSTPTLVEVSRNLGKVGSKCCKHPEAKRMPCAEDYLSVVLNQLCVLHEKTPVSDRVTKCCTESLVNRRPCFSALEVDETYVPKEFNAETFTFHADICTLSEKERQIKKQTALVELVKHKPKATKEQLKAVMDDFAAFVEKCCKADDKETCFAEEGKKLVAASQAALGL"
seq_BSA = "MKWVTFISLLLLFSSAYSRGVFRRDTHKSEIAHRFKDLGEEHFKGLVLIAFSQYLQQCPFDEHVKLVNELTEFAKTCVADESHAGCEKSLHTLFGDELCKVASLRETYGDMADCCEKQEPERNECFLSHKDDSPDLPKLKPDPNTLCDEFKADEKKFWGKYLYEIARRHPYFYAPELLYYANKYNGVFQECCQAEDKGACLLPKIETMREKVLASSARQRLRCASIQKFGERALKAWSVARLSQKFPKAEFVEVTKLVTDLTKVHKECCHGDLLECADDRADLAKYICDNQDTISSKLKECCDKPLLEKSHCIAEVEKDAIPENLPPLTADFAEDKDVCKNYQEAKDAFLGSFLYEYSRRHPEYAVSVLLRLAKEYEATLEECCAKDDPHACYSTVFDKLKHLVDEPQNLIKQNCDQFEKLGEYGFQNALIVRYTRKVPQVSTPTLVEVSRSLGKVGTRCCTKPESERMPCTEDYLSLILNRLCVLHEKTPVSEKVTKCCTESLVNRRPCFSALTPDETYVPKAFDEKLFTFHADICTLPDTEKQIKKQTALVELLKHKPKATEEQLKTVMENFVAFVDKCCAADDKEACFAVEGPKLVVSTQTALA"
seq_MSA = "MKWVTFLLLLFVSGSAFSRGVFRREAHKSEIAHRYNDLGEQHFKGLVLIAFSQYLQKCSYDEHAKLVQEVTDFAKTCVADESAANCDKSLHTLFGDKLCAIPNLRENYGELADCCTKQEPERNECFLQHKDDNPSLPPFERPEAEAMCTSFKENPTTFMGHYLHEVARRHPYFYAPELLYYAEQYNEILTQCCAEADKESCLTPKLDGVKEKALVSSVRQRMKCSSMQKFGERAFKAWAVARLSQTFPNADFAEITKLATDLTKVNKECCHGDLLECADDRAELAKYMCENQATISSKLQTCCDKPLLKKAHCLSEVEHDTMPADLPAIAADFVEDQEVCKNYAEAKDVFLGTFLYEYSRRHPDYSVSLLLRLAKKYEATLEKCCAEANPPACYGTVLAEFQPLVEEPKNLVKTNCDLYEKLGEYGFQNAILVRYTQKAPQVSTPTLVEAARNLGRVGTKCCTLPEDQRLPCVEDYLSAILNRVCLLHEKTPVSEHVTKCCSGSLVERRPCFSALTVDETYVPKEFKAETFTFHSDICTLPEKEKQIKKQTALAELVKHKPKATAEQLKTVMDDFAQFLDTCCKAADKDTCFSTEGPNLVTRCKDALA"
seq_Chymotrypsin = 'CGVPAIQPVLSGLARIVNGEDAVPGSWPWQVSLQDSTGFHFCGGSLISEDWVVTAAHCGVTTSDVVVAGEFDQGLETEDTQVLKIGKVFKNPKFSILTVRNDITLLKLATPAQFSETVSAVCLPSADEDFPAGMLCATTGWGKTKYNALKTPDKLQQATLPIVSNTDCRKYWGSRVTDVMICAGASGVSSCMGDSGGPLVCQKNGAWTLAGIVSWGSSTCSTSTPAVYARVTALMPWVQETLAAN'
seq_Trypsin = "FPTDDDDKIVGGYTCAANSIPYQVSLNSGSHFCGGSLINSQWVVSAAHCYKSRIQVRLGEHNIDVLEGNEQFINAAKIITHPNFNGNTLDNDIMLIKLSSPATLNSRVATVSLPRSCAAAGTECLISGWGNTKSSGSSYPSLLQCLKAPVLSDSSCKSSYPGQITGNMICVGFLEGGKDSCQGDSGGPVVCNGQLQGIVSWGYGCAQKNKPGVYTKVCNYVNWIQQTIAAN"
seq_IL1 = "MAKVPDMFEDLKNCYSENEEDSSSIDHLSLNQKSFYHVSYGPLHEGCMDQSVSLSISETSKTSKLTFKESMVVVATNGKVLKKRRLSLSQSITDDDLEAIANDSEEEIIKPRSAPFSFLSNVKYNFMRIIKYEFILNDALNQSIIRANDQYLTAAALHNLDEAVKFDMGAYKSSKDDAKITVILRISKTQLYVTAQDEDQPVLLKEMPEIPKTITGSETNLLFFWETHGTKNYFTSVAHPNLFIATKQDYWVCLAGGPPSITDFQILENQA"
seq_hADAMTS1 = "MQRAVPEGFGRRKLGSDMGNAERAPGSRSFGPVPTLLLLAAALLAVSDALGRPSEEDEELVVPELERAPGHGTTRLRLHAFDQQLDLELRPDSSFLAPGFTLQNVGRKSGSETPLPETDLAHCFYSGTVNGDPSSAAALSLCEGVRGAFYLLGEAYFIQPLPAASERLATAAPGEKPPAPLQFHLLRRNRQGDVGGTCGVVDDEPRPTGKAETEDEDEGTEGEDEGAQWSPQDPALQGVGQPTGTGSIRKKRFVSSHRYVETMLVADQSMAEFHGSGLKHYLLTLFSVAARLYKHPSIRNSVSLVVVKILVIHDEQKGPEVTSNAALTLRNFCNWQKQHNPPSDRDAEHYDTAILFTRQDLCGSQTCDTLGMADVGTVCDPSRSCSVIEDDGLQAAFTTAHELGHVFNMPHDDAKQCASLNGVNQDSHMMASMLSNLDHSQPWSPCSAYMITSFLDNGHGECLMDKPQNPIQLPGDLPGTSYDANRQCQFTFGEDSKHCPDAASTCSTLWCTGTSGGVLVCQTKHFPWADGTSCGEGKWCINGKCVNKTDRKHFDTPFHGSWGMWGPWGDCSRTCGGGVQYTMRECDNPVPKNGGKYCEGKRVRYRSCNLEDCPDNNGKTFREEQCEAHNEFSKASFGSGPAVEWIPKYAGVSPKDRCKLICQAKGIGYFFVLQPKVVDGTPCSPDSTSVCVQGQCVKAGCDRIIDSKKKFDKCGVCGGNGSTCKKISGSVTSAKPGYHDIITIPTGATNIEVKQRNQRGSRNNGSFLAIKAADGTYILNGDYTLSTLEQDIMYKGVVLRYSGSSAALERIRSFSPLKEPLTIQVLTVGNALRPKIKYTYFVKKKKESFNAIPTFSAWVIEEWGECSKSCELGWQRRLVECRDINGQPASECAKEVKPASTRPCADHPCPQWQLGEWSSCSKTCGKGYKKRSLKCLSHDGGVLSHESCDPLKKPKHFIDFCTMAECS"
seq_hADAMTS2 = "MDPPAGAARRLLCPALLLLLLLLPPPLLPPPPPPANARLAAAADPPGGPLGHGAERILAVPVRTDAQGRLVSHVVSAATSRAGVRARRAAPVRTPSFPGGNEEEPGSHLFYNVTVFGRDLHLRLRPNARLVAPGATMEWQGEKGTTRVEPLLGSCLYVGDVAGLAEASSVALSNCDGLAGLIRMEEEEFFIEPLEKGLAAQEAEQGRVHVVYRRPPTSPPLGGPQALDTGASLDSLDSLSRALGVLEEHANSSRRRARRHAADDDYNIEVLLGVDDSVVQFHGKEHVQKYLLTLMNIVNEIYHDESLGAHINVVLVRIILLSYGKSMSLIEIGNPSQSLENVCRWAYLQQKPDTGHDEYHDHAIFLTRQDFGPSGMQGYAPVTGMCHPVRSCTLNHEDGFSSAFVVAHETGHVLGMEHDGQGNRCGDEVRLGSIMAPLVQAAFHRFHWSRCSQQELSRYLHSYDCLLDDPFAHDWPALPQLPGLHYSMNEQCRFDFGLGYMMCTAFRTFDPCKQLWCSHPDNPYFCKTKKGPPLDGTMCAPGKHCFKGHCIWLTPDILKRDGSWGAWSPFGSCSRTCGTGVKFRTRQCDNPHPANGGRTCSGLAYDFQLCSRQDCPDSLADFREEQCRQWDLYFEHGDAQHHWLPHEHRDAKERCHLYCESRETGEVVSMKRMVHDGTRCSYKDAFSLCVRGDCRKVGCDGVIGSSKQEDKCGVCGGDNSHCKVVKGTFTRSPKKHGYIKMFEIPAGARHLLIQEVDATSHHLAVKNLETGKFILNEENDVDASSKTFIAMGVEWEYRDEDGRETLQTMGPLHGTITVLVIPVGDTRVSLTYKYMIHEDSLNVDDNNVLEEDSVVYEWALKKWSPCSKPCGGGSQFTKYGCRRRLDHKMVHRGFCAALSKPKAIRRACNPQECSQPVWVTGEWEPCSQTCGRTGMQVRSVRCIQPLHDNTTRSVHAKHCNDARPESRRACSRELCPGRWRAGPWSQCSVTCGNGTQERPVLCRTADDSFGICQEERPETARTCRLGPCPRNISDPSKKSYVVQWLSRPDPDSPIRKISSKGHCQGDKSIFCRMEVLSRYCSIPGYNKLCCKSCNLYNNLTNVEGRIEPPPGKHNDIDVFMPTLPVPTVAMEVRPSPSTPLEVPLNASSTNATEDHPETNAVDEPYKIHGLEDEVQPPNLIPRRPSPYEKTRNQRIQELIDEMRKKEMLGKF"
seq_hADAMTS3 = "MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVTPVSTNLEGRYLSHTLSASHKKRSARDVSSNPEQLFFNITAFGKDFHLRLKPNTQLVAPGAVVEWHETSLVPGNITDPINNHQPGSATYRIRRTEPLQTNCAYVGDIVDIPGTSVAISNCDGLAGMIKSDNEEYFIEPLERGKQMEEEKGRIHVVYKRSAVEQAPIDMSKDFHYRESDLEGLDDLGTVYGNIHQQLNETMRRRRHAGENDYNIEVLLGVDDSVVRFHGKEHVQNYLLTLMNIVNEIYHDESLGVHINVVLVRMIMLGYAKSISLIERGNPSRSLENVCRWASQQQRSDLNHSEHHDHAIFLTRQDFGPAGMQGYAPVTGMCHPVRSCTLNHEDGFSSAFVVAHETGHVLGMEHDGQGNRCGDETAMGSVMAPLVQAAFHRYHWSRCSGQELKRYIHSYDCLLDDPFDHDWPKLPELPGINYSMDEQCRFDFGVGYKMCTAFRTFDPCKQLWCSHPDNPYFCKTKKGPPLDGTECAAGKWCYKGHCMWKNANQQKQDGNWGSWTKFGSCSRTCGTGVRFRTRQCNNPMPINGGQDCPGVNFEYQLCNTEECQKHFEDFRAQQCQQRNSHFEYQNTKHHWLPYEHPDPKKRCHLYCQSKETGDVAYMKQLVHDGTHCSYKDPYSICVRGECVKVGCDKEIGSNKVEDKCGVCGGDNSHCRTVKGTFTRTPRKLGYLKMFDIPPGARHVLIQEDEASPHILAIKNQATGHYILNGKGEEAKSRTFIDLGVEWDYNIEDDIESLHTDGPLHDPVIVLIIPQENDTRSSLTYKYIIHEDSVPTINSNNVIQEELDTFEWALKSWSQCSKPCGGGFQYTKYGCRRKSDNKMVHRSFCEANKKPKPIRRMCNIQECTHPLWVAEEWEHCTKTCGSSGYQLRTVRCLQPLLDGTNRSVHSKYCMGDRPESRRPCNRVPCPAQWKTGPWSECSVTCGEGTEVRQVLCRAGDHCDGEKPESVRACQLPPCNDEPCLGDKSIFCQMEVLARYCSIPGYNKLCCESCSKRSSTLPPPYLLEAAETHDDVISNPSDLPRSLVMPTSLVPYHSETPAKKMSLSSISSVGGPNAYAAFRPNSKPDGANLRQRSAQQAGSKTVRLVTVPSSPPTKRVHLSSASQMAAASFFAASDSIGASSQARTSKKDGKIIDNRRPTRSSTLER"
seq_hADAMTS4 = "MSQTGSHPGRGLAGRWLWGAQPCLLLPIVPLSWLVWLLLLLLASLLPSARLASPLPREEEIVFPEKLNGSVLPGSGAPARLLCRLQAFGETLLLELEQDSGVQVEGLTVQYLGQAPELLGGAEPGTYLTGTINGDPESVASLHWDGGALLGVLQYRGAELHLQPLEGGTPNSAGGPGAHILRRKSPASGQGPMCNVKAPLGSPSPRPRRAKRFASLSRFVETLVVADDKMAAFHGAGLKRYLLTVMAAAAKAFKHPSIRNPVSLVVTRLVILGSGEEGPQVGPSAAQTLRSFCAWQRGLNTPEDSDPDHFDTAILFTRQDLCGVSTCDTLGMADVGTVCDPARSCAIVEDDGLQSAFTAAHELGHVFNMLHDNSKPCISLNGPLSTSRHVMAPVMAHVDPEEPWSPCSARFITDFLDNGYGHCLLDKPEAPLHLPVTFPGKDYDADRQCQLTFGPDSRHCPQLPPPCAALWCSGHLNGHAMCQTKHSPWADGTPCGPAQACMGGRCLHMDQLQDFNIPQAGGWGPWGPWGDCSRTCGGGVQFSSRDCTRPVPRNGGKYCEGRRTRFRSCNTEDCPTGSALTFREEQCAAYNHRTDLFKSFPGPMDWVPRYTGVAPQDQCKLTCQAQALGYYYVLEPRVVDGTPCSPDSSSVCVQGRCIHAGCDRIIGSKKKFDKCMVCGGDGSGCSKQSGSFRKFRYGYNNVVTIPAGATHILVRQQGNPGHRSIYLALKLPDGSYALNGEYTLMPSPTDVVLPGAVSLRYSGATAASETLSGHGPLAQPLTLQVLVAGNPQDTRLRYSFFVPRPTPSTPRPTPQDWLHRRAQILEILRRRPWAGRK"
seq_hADAMTS5 = "MLLGWASLLLCAFRLPLAAVGPAATPAQDKAGQPPTAAAAAQPRRRQGEEVQERAEPPGHPHPLAQRRRSKGLVQNIDQLYSGGGKVGYLVYAGGRRFLLDLERDGSVGIAGFVPAGGGTSAPWRHRSHCFYRGTVDGSPRSLAVFDLCGGLDGFFAVKHARYTLKPLLRGPWAEEEKGRVYGDGSARILHVYTREGFSFEALPPRASCETPASTPEAHEHAPAHSNPSGRAALASQLLDQSALSPAGGSGPQTWWRRRRRSISRARQVELLLVADASMARLYGRGLQHYLLTLASIANRLYSHASIENHIRLAVVKVVVLGDKDKSLEVSKNAATTLKNFCKWQHQHNQLGDDHEEHYDAAILFTREDLCGHHSCDTLGMADVGTICSPERSCAVIEDDGLHAAFTVAHEIGHLLGLSHDDSKFCEETFGSTEDKRLMSSILTSIDASKPWSKCTSATITEFLDDGHGNCLLDLPRKQILGPEELPGQTYDATQQCNLTFGPEYSVCPGMDVCARLWCAVVRQGQMVCLTKKLPAVEGTPCGKGRICLQGKCVDKTKKKYYSTSSHGNWGSWGSWGQCSRSCGGGVQFAYRHCNNPAPRNNGRYCTGKRAIYRSCSLMPCPPNGKSFRHEQCEAKNGYQSDAKGVKTFVEWVPKYAGVLPADVCKLTCRAKGTGYYVVFSPKVTDGTECRLYSNSVCVRGKCVRTGCDGIIGSKLQYDKCGVCGGDNSSCTKIVGTFNKKSKGYTDVVRIPEGATHIKVRQFKAKDQTRFTAYLALKKKNGEYLINGKYMISTSETIIDINGTVMNYSGWSHRDDFLHGMGYSATKEILIVQILATDPTKPLDVRYSFFVPKKSTPKVNSVTSHGSNKVGSHTSQPQWVTGPWLACSRTCDTGWHTRTVQCQDGNRKLAKGCPLSQRPSAFKQCLLKKC"
seq_hADAMTS6 = "MEILWKTLTWILSLIMASSEFHSDHRLSYSSQEEFLTYLEHYQLTIPIRVDQNGAFLSFTVKNDKHSRRRRSMDPIDPQQAVSKLFFKLSAYGKHFHLNLTLNTDFVSKHFTVEYWGKDGPQWKHDFLDNCHYTGYLQDQRSTTKVALSNCVGLHGVIATEDEEYFIEPLKNTTEDSKHFSYENGHPHVIYKKSALQQRHLYDHSHCGVSDFTRSGKPWWLNDTSTVSYSLPINNTHIHHRQKRSVSIERFVETLVVADKMMVGYHGRKDIEHYILSVMNIVAKLYRDSSLGNVVNIIVARLIVLTEDQPNLEINHHADKSLDSFCKWQKSILSHQSDGNTIPENGIAHHDNAVLITRYDICTYKNKPCGTLGLASVAGMCEPERSCSINEDIGLGSAFTIAHEIGHNFGMNHDGIGNSCGTKGHEAAKLMAAHITANTNPFSWSACSRDYITSFLDSGRGTCLDNEPPKRDFLYPAVAPGQVYDADEQCRFQYGATSRQCKYGEVCRELWCLSKSNRCVTNSIPAAEGTLCQTGNIEKGWCYQGDCVPFGTWPQSIDGGWGPWSLWGECSRTCGGGVSSSLRHCDSPAPSGGGKYCLGERKRYRSCNTDPCPLGSRDFREKQCADFDNMPFRGKYYNWKPYTGGGVKPCALNCLAEGYNFYTERAPAVIDGTQCNADSLDICINGECKHVGCDNILGSDAREDRCRVCGGDGSTCDAIEGFFNDSLPRGGYMEVVQIPRGSVHIEVREVAMSKNYIALKSEGDDYYINGAWTIDWPRKFDVAGTAFHYKRPTDEPESLEALGPTSENLIVMVLLQEQNLGIRYKFNVPITRTGSGDNEVGFTWNHQPWSECSATCAGGVQRQEVVCKRLDDNSIVQNNYCDPDSKPPENQRACNTEPCPPEWFIGDWLECSKTCDGGMRTRAVLCIRKIGPSEEETLDYSGCLTHRPVEKEPCNNQSCPPQWVALDWSECTPKCGPGFKHRIVLCKSSDLSKTFPAAQCPEESKPPVRIRCSLGRCPPPRWVTGDWGQCSAQCGLGQQMRTVQCLSYTGQASSDCLETVRPPSMQQCESKCDSTPISNTEECKDVNKVAYCPLVLKFKFCSRAYFRQMCCKTCQGH"
seq_hADAMTS7 = "MPGGPSPRSPAPLLRPLLLLLCALAPGAPGPAPGRATEGRAALDIVHPVRVDAGGSFLSYELWPRALRKRDVSVRRDAPAFYELQYRGRELRFNLTANQHLLAPGFVSETRRRGGLGRAHIRAHTPACHLLGEVQDPELEGGLAAISACDGLKGVFQLSNEDYFIEPLDSAPARPGHAQPHVVYKRQAPERLAQRGDSSAPSTCGVQVYPELESRRERWEQRQQWRRPRLRRLHQRSVSKEKWVETLVVADAKMVEYHGQPQVESYVLTIMNMVAGLFHDPSIGNPIHITIVRLVLLEDEEEDLKITHHADNTLKSFCKWQKSINMKGDAHPLHHDTAILLTRKDLCAAMNRPCETLGLSHVAGMCQPHRSCSINEDTGLPLAFTVAHELGHSFGIQHDGSGNDCEPVGKRPFIMSPQLLYDAAPLTWSRCSRQYITRFLDRGWGLCLDDPPAKDIIDFPSVPPGVLYDVSHQCRLQYGAYSAFCEDMDNVCHTLWCSVGTTCHSKLDAAVDGTRCGENKWCLSGECVPVGFRPEAVDGGWSGWSAWSICSRSCGMGVQSAERQCTQPTPKYKGRYCVGERKRFRLCNLQACPAGRPSFRHVQCSHFDAMLYKGQLHTWVPVVNDVNPCELHCRPANEYFAEKLRDAVVDGTPCYQVRASRDLCINGICKNVGCDFEIDSGAMEDRCGVCHGNGSTCHTVSGTFEEAEGLGYVDVGLIPAGAREIRIQEVAEAANFLALRSEDPEKYFLNGGWTIQWNGDYQVAGTTFTYARRGNWENLTSPGPTKEPVWIQLLFQESNPGVHYEYTIHREAGGHDEVPPPVFSWHYGPWTKCTVTCGRGVQRQNVYCLERQAGPVDEEHCDPLGRPDDQQRKCSEQPCPARWWAGEWQLCSSSCGPGGLSRRAVLCIRSVGLDEQSALEPPACEHLPRPPTETPCNRHVPCPATWAVGNWSQCSVTCGEGTQRRNVLCTNDTGVPCDEAQQPASEVTCSLPLCRWPLGTLGPEGSGSGSSSHELFNEADFIPHHLAPRPSPASSPKPGTMGNAIEEEAPELDLPGPVFVDDFYYDYNFINFHEDLSYGPSEEPDLDLAGTGDRTPPPHSHPAAPSTGSPVPATEPPAAKEEGVLGPWSPSPWPSQAGRSPPPPSEQTPGNPLINFLPEEDTPIGAPDLGLPSLSWPRVSTDGLQTPATPESQNDFPVGKDSQSQLPPPWRDRTNEVFKDDEEPKGRGAPHLPPRPSSTLPPLSPVGSTHSSPSPDVAELWTGGTVAWEPALEGGLGPVDSELWPTVGVASLLPPPIAPLPEMKVRDSSLEPGTPSFPTPGPGSWDLQTVAVWGTFLPTTLTGLGHMPEPALNPGPKGQPESLSPEVPLSSRLLSTPAWDSPANSHRVPETQPLAPSLAEAGPPADPLVVRNAGWQAGNWSECSTTCGLGAVWRPVRCSSGRDEDCAPAGRPQPARRCHLRPCATWHSGNWSKCSRSCGGGSSVRDVQCVDTRDLRPLRPFHCQPGPAKPPAHRPCGAQPCLSWYTSSWRECSEACGGGEQQRLVTCPEPGLCEEALRPNTTRPCNTHPCTQWVVGPWGQCSGPCGGGVQRRLVKCVNTQTGLPEEDSDQCGHEAWPESSRPCGTEDCEPVEPPRCERDRLSFGFCETLRLLGRCQLPTIRTQCCRSCSPPSHGAPSRGHQRVARR"
seq_hADAMTS9 = "MQFVSWATLLTLLVRDLAEMGSPDAAAAVRKDRLHPRQVKLLETLSEYEIVSPIRVNALGEPFPTNVHFKRTRRSINSATDPWPAFASSSSSSTSSQAHYRLSAFGQQFLFNLTANAGFIAPLFTVTLLGTPGVNQTKFYSEEEAELKHCFYKGYVNTNSEHTAVISLCSGMLGTFRSHDGDYFIEPLQSMDEQEDEEEQNKPHIIYRRSAPQREPSTGRHACDTSEHKNRHSKDKKKTRARKWGERINLAGDVAALNSGLATEAFSAYGNKTDNTREKRTHRRTKRFLSYPRFVEVLVVADNRMVSYHGENLQHYILTLMSIVASIYKDPSIGNLINIVIVNLIVIHNEQDGPSISFNAQTTLKNFCQWQHSKNSPGGIHHDTAVLLTRQDICRAHDKCDTLGLAELGTICDPYRSCSISEDSGLSTAFTIAHELGHVFNMPHDDNNKCKEEGVKSPQHVMAPTLNFYTNPWMWSKCSRKYITEFLDTGYGECLLNEPESRPYPLPVQLPGILYNVNKQCELIFGPGSQVCPYMMQCRRLWCNNVNGVHKGCRTQHTPWADGTECEPGKHCKYGFCVPKEMDVPVTDGSWGSWSPFGTCSRTCGGGIKTAIRECNRPEPKNGGKYCVGRRMKFKSCNTEPCLKQKRDFRDEQCAHFDGKHFNINGLLPNVRWVPKYSGILMKDRCKLFCRVAGNTAYYQLRDRVIDGTPCGQDTNDICVQGLCRQAGCDHVLNSKARRDKCGVCGGDNSSCKTVAGTFNTVHYGYNTVVRIPAGATNIDVRQHSFSGETDDDNYLALSSSKGEFLLNGNFVVTMAKREIRIGNAVVEYSGSETAVERINSTDRIEQELLLQVLSVGKLYNPDVRYSFNIPIEDKPQQFYWNSHGPWQACSKPCQGERKRKLVCTRESDQLTVSDQRCDRLPQPGHITEPCGTDCDLRWHVASRSECSAQCGLGYRTLDIYCAKYSRLDGKTEKVDDGFCSSHPKPSNREKCSGECNTGGWRYSAWTECSKSCDGGTQRRRAICVNTRNDVLDDSKCTHQEKVTIQRCSEFPCPQWKSGDWSECLVTCGKGHKHRQVWCQFGEDRLNDRMCDPETKPTSMQTCQQPECASWQAGPWGQCSVTCGQGYQLRAVKCIIGTYMSVVDDNDCNAATRPTDTQDCELPSCHPPPAAPETRRSTYSAPRTQWRFGSWTPCSATCGKGTRMRYVSCRDENGSVADESACATLPRPVAKEECSVTPCGQWKALDWSSCSVTCGQGRATRQVMCVNYSDHVIDRSECDQDYIPETDQDCSMSPCPQRTPDSGLAQHPFQNEDYRPRSASPSRTHVLGGNQWRTGPWGACSSTCAGGSQRRVVVCQDENGYTANDCVERIKPDEQRACESGPCPQWAYGNWGECTKLCGGGIRTRLVVCQRSNGERFPDLSCEILDKPPDREQCNTHACPHDAAWSTGPWSSCSVSCGRGHKQRNVYCMAKDGSHLESDYCKHLAKPHGHRKCRGGRCPKWKAGAWSQCSVSCGRGVQQRHVGCQIGTHKIARETECNPYTRPESERDCQGPRCPLYTWRAEEWQECTKTCGEGSRYRKVVCVDDNKNEVHGARCDVSKRPVDRESCSLQPCEYVWITGEWSECSVTCGKGYKQRLVSCSEIYTGKENYEYSYQTTINCPGTQPPSVHPCYLRDCPVSATWRVGNWGSCSVSCGVGVMQRSVQCLTNEDQPSHLCHTDLKPEERKTCRNVYNCELPQNCKEVKRLKGASEDGEYFLMIRGKLLKIFCAGMHSDHPKEYVTLVHGDSENFSEVYGHRLHNPTECPYNGSRRDDCQCRKDYTAAGFSSFQKIRIDLTSMQIITTDLQFARTSEGHPVPFATAGDCYSAAKCPQGRFSINLYGTGLSLTESARWISQGNYAVSDIKKSPDGTRVVGKCGGYCGKCTPSSGTGLEVRVL"
seq_hADAMTS10 = "MAPACQILRWALALGLGLMFEVTHAFRSQDEFLSSLESYEIAFPTRVDHNGALLAFSPPPPRRQRRGTGATAESRLFYKVASPSTHFLLNLTRSSRLLAGHVSVEYWTREGLAWQRAARPHCLYAGHLQGQASTSHVAISTCGGLHGLIVADEEEYLIEPLHGGPKGSRSPEESGPHVVYKRSSLRHPHLDTACGVRDEKPWKGRPWWLRTLKPPPARPLGNETERGQPGLKRSVSRERYVETLVVADKMMVAYHGRRDVEQYVLAIMNIVAKLFQDSSLGSTVNILVTRLILLTEDQPTLEITHHAGKSLDSFCKWQKSIVNHSGHGNAIPENGVANHDTAVLITRYDICIYKNKPCGTLGLAPVGGMCERERSCSVNEDIGLATAFTIAHEIGHTFGMNHDGVGNSCGARGQDPAKLMAAHITMKTNPFVWSSCSRDYITSFLDSGLGLCLNNRPPRQDFVYPTVAPGQAYDADEQCRFQHGVKSRQCKYGEVCSELWCLSKSNRCITNSIPAAEGTLCQTHTIDKGWCYKRVCVPFGSRPEGVDGAWGPWTPWGDCSRTCGGGVSSSSRHCDSPRPTIGGKYCLGERRRHRSCNTDDCPPGSQDFREVQCSEFDSIPFRGKFYKWKTYRGGGVKACSLTCLAEGFNFYTERAAAVVDGTPCRPDTVDICVSGECKHVGCDRVLGSDLREDKCRVCGGDGSACETIEGVFSPASPGAGYEDVVWIPKGSVHIFIQDLNLSLSHLALKGDQESLLLEGLPGTPQPHRLPLAGTTFQLRQGPDQVQSLEALGPINASLIVMVLARTELPALRYRFNAPIARDSLPPYSWHYAPWTKCSAQCAGGSQVQAVECRNQLDSSAVAPHYCSAHSKLPKRQRACNTEPCPPDWVVGNWSLCSRSCDAGVRSRSVVCQRRVSAAEEKALDDSACPQPRPPVLEACHGPTCPPEWAALDWSECTPSCGPGLRHRVVLCKSADHRATLPPAHCSPAAKPPATMRCNLRRCPPARWVAGEWGECSAQCGVGQRQRSVRCTSHTGQASHECTEALRPPTTQQCEAKCDSPTPGDGPEECKDVNKVAYCPLVLKFQFCSRAYFRQMCCKTCHGH"
seq_hADAMTS12 = "MPCAQRSWLANLSVVAQLLNFGALCYGRQPQPGPVRFPDRRQEHFIKGLPEYHVVGPVRVDASGHFLSYGLHYPITSSRRKRDLDGSEDWVYYRISHEEKDLFFNLTVNQGFLSNSYIMEKRYGNLSHVKMMASSAPLCHLSGTVLQQGTRVGTAALSACHGLTGFFQLPHGDFFIEPVKKHPLVEGGYHPHIVYRRQKVPETKEPTCGLKDSVNISQKQELWREKWERHNLPSRSLSRRSISKERWVETLVVADTKMIEYHGSENVESYILTIMNMVTGLFHNPSIGNAIHIVVVRLILLEEEEQGLKIVHHAEKTLSSFCKWQKSINPKSDLNPVHHDVAVLLTRKDICAGFNRPCETLGLSHLSGMCQPHRSCNINEDSGLPLAFTIAHELGHSFGIQHDGKENDCEPVGRHPYIMSRQLQYDPTPLTWSKCSEEYITRFLDRGWGFCLDDIPKKKGLKSKVIAPGVIYDVHHQCQLQYGPNATFCQEVENVCQTLWCSVKGFCRSKLDAAADGTQCGEKKWCMAGKCITVGKKPESIPGGWGRWSPWSHCSRTCGAGVQSAERLCNNPEPKFGGKYCTGERKRYRLCNVHPCRSEAPTFRQMQCSEFDTVPYKNELYHWFPIFNPAHPCELYCRPIDGQFSEKMLDAVIDGTPCFEGGNSRNVCINGICKMVGCDYEIDSNATEDRCGVCLGDGSSCQTVRKMFKQKEGSGYVDIGLIPKGARDIRVMEIEGAGNFLAIRSEDPEKYYLNGGFIIQWNGNYKLAGTVFQYDRKGDLEKLMATGPTNESVWIQLLFQVTNPGIKYEYTIQKDGLDNDVEQQMYFWQYGHWTECSVTCGTGIRRQTAHCIKKGRGMVKATFCDPETQPNGRQKKCHEKACPPRWWAGEWEACSATCGPHGEKKRTVLCIQTMVSDEQALPPTDCQHLLKPKTLLSCNRDILCPSDWTVGNWSECSVSCGGGVRIRSVTCAKNHDEPCDVTRKPNSRALCGLQQCPSSRRVLKPNKGTISNGKNPPTLKPVPPPTSRPRMLTTPTGPESMSTSTPAISSPSPTTASKEGDLGGKQWQDSSTQPELSSRYLISTGSTSQPILTSQSLSIQPSEENVSSSDTGPTSEGGLVATTTSGSGLSSSRNPITWPVTPFYNTLTKGPEMEIHSGSGEEREQPEDKDESNPVIWTKIRVPGNDAPVESTEMPLAPPLTPDLSRESWWPPFSTVMEGLLPSQRPTTSETGTPRVEGMVTEKPANTLLPLGGDHQPEPSGKTANRNHLKLPNNMNQTKSSEPVLTEEDATSLITEGFLLNASNYKQLTNGHGSAHWIVGNWSECSTTCGLGAYWRRVECSTQMDSDCAAIQRPDPAKRCHLRPCAGWKVGNWSKCSRNCSGGFKIREIQCVDSRDHRNLRPFHCQFLAGIPPPLSMSCNPEPCEAWQVEPWSQCSRSCGGGVQERGVFCPGGLCDWTKRPTSTMSCNEHLCCHWATGNWDLCSTSCGGGFQKRTVQCVPSEGNKTEDQDQCLCDHKPRPPEFKKCNQQACKKSADLLCTKDKLSASFCQTLKAMKKCSVPTVRAECCFSCPQTHITHTQRQRRQRLLQKSKEL"
seq_hADAMTS13 = "MHQRHPRARCPPLCVAGILACGFLLGCWGPSHFQQSCLQALEPQAVSSYLSPGAPLKGRPPSPGFQRQRQRQRRAAGGILHLELLVAVGPDVFQAHQEDTERYVLTNLNIGAELLRDPSLGAQFRVHLVKMVILTEPEGAPNITANLTSSLLSVCGWSQTINPEDDTDPGHADLVLYITRFDLELPDGNRQVRGVTQLGGACSPTWSCLITEDTGFDLGVTIAHEIGHSFGLEHDGAPGSGCGPSGHVMASDGAAPRAGLAWSPCSRRQLLSLLSAGRARCVWDPPRPQPGSAGHPPDAQPGLYYSANEQCRVAFGPKAVACTFAREHLDMCQALSCHTDPLDQSSCSRLLVPLLDGTECGVEKWCSKGRCRSLVELTPIAAVHGRWSSWGPRSPCSRSCGGGVVTRRRQCNNPRPAFGGRACVGADLQAEMCNTQACEKTQLEFMSQQCARTDGQPLRSSPGGASFYHWGAAVPHSQGDALCRHMCRAIGESFIMKRGDSFLDGTRCMPSGPREDGTLSLCVSGSCRTFGCDGRMDSQQVWDRCQVCGGDNSTCSPRKGSFTAGRAREYVTFLTVTPNLTSVYIANHRPLFTHLAVRIGGRYVVAGKMSISPNTTYPSLLEDGRVEYRVALTEDRLPRLEEIRIWGPLQEDADIQVYRRYGEEYGNLTRPDITFTYFQPKPRQAWVWAAVRGPCSVSCGAGLRWVNYSCLDQARKELVETVQCQGSQQPPAWPEACVLEPCPPYWAVGDFGPCSASCGGGLRERPVRCVEAQGSLLKTLPPARCRAGAQQPAVALETCNPQPCPARWEVSEPSSCTSAGGAGLALENETCVPGADGLEAPVTEGPGSVDEKLPAPEPCVGMSCPPGWGHLDATSAGEKAPSPWGSIRTGAQAAHVWTPAAGSCSVSCGRGLMELRFLCMDSALRVPVQEELCGLASKPGSRREVCQAVPCPARWQYKLAACSVSCGRGVVRRILYCARAHGEDDGEEILLDTQCQGLPRPEPQEACSLEPCPPRWKVMSLGPCSASCGLGTARRSVACVQLDQGQDVEVDEAACAALVRPEASVPCLIADCTYRWHVGTWMECSVSCGDGIQRRRDTCLGPQAQAPVPADFCQHLPKPVTVRGCWAGPCVGQGTPSLVPHEEAAAPGRTTATPAGASLEWSQARGLLFSPAPQPRRLLPGPQENSVQSSACGRQHLEPTGTIDMRGPGQADCAVAIGRPLGEVVTLRVLESSLNCSAGDMLLLWGRLTWRKMCRKLLDMTFSSKTNTLVVRQRCGRPGGGVLLRYGSQLAPETFYRECDMQLFGPWGEIVSPSLSPATSNAGGCRLFINVAPHARIAIHALATNMGAGTEGANASYILIRDTHSLRTTAFHGQQVLYWESESSQAEMEFSEGFLKAQASLRGQYWTLQSWVPEMQDPQSWKGKEGT"
seq_hADAMTS14 = "MAPLRALLSYLLPLHCALCAAAGSRTPELHLSGKLSDYGVTVPCSTDFRGRFLSHVVSGPAAASAGSMVVDTPPTLPRHSSHLRVARSPLHPGGTLWPGRVGRHSLYFNVTVFGKELHLRLRPNRRLVVPGSSVEWQEDFRELFRQPLRQECVYTGGVTGMPGAAVAISNCDGLAGLIRTDSTDFFIEPLERGQQEKEASGRTHVVYRREAVQQEWAEPDGDLHNEAFGLGDLPNLLGLVGDQLGDTERKRRHAKPGSYSIEVLLVVDDSVVRFHGKEHVQNYVLTLMNIVDEIYHDESLGVHINIALVRLIMVGYRQSLSLIERGNPSRSLEQVCRWAHSQQRQDPSHAEHHDHVVFLTRQDFGPSGYAPVTGMCHPLRSCALNHEDGFSSAFVIAHETGHVLGMEHDGQGNGCADETSLGSVMAPLVQAAFHRFHWSRCSKLELSRYLPSYDCLLDDPFDPAWPQPPELPGINYSMDEQCRFDFGSGYQTCLAFRTFEPCKQLWCSHPDNPYFCKTKKGPPLDGTECAPGKWCFKGHCIWKSPEQTYGQDGGWSSWTKFGSCSRSCGGGVRSRSRSCNNPSPAYGGRLCLGPMFEYQVCNSEECPGTYEDFRAQQCAKRNSYYVHQNAKHSWVPYEPDDDAQKCELICQSADTGDVVFMNQVVHDGTRCSYRDPYSVCARGECVPVGCDKEVGSMKADDKCGVCGGDNSHCRTVKGTLGKASKQAGALKLVQIPAGARHIQIEALEKSPHRIVVKNQVTGSFILNPKGKEATSRTFTAMGLEWEDAVEDAKESLKTSGPLPEAIAILALPPTEGGPRSSLAYKYVIHEDLLPLIGSNNVLLEEMDTYEWALKSWAPCSKACGGGIQFTKYGCRRRRDHHMVQRHLCDHKKRPKPIRRRCNQHPCSQPVWVTEEWGACSRSCGKLGVQTRGIQCLLPLSNGTHKVMPAKACAGDRPEARRPCLRVPCPAQWRLGAWSQCSATCGEGIQQRQVVCRTNANSLGHCEGDRPDTVQVCSLPACGGNHQNSTVRADVWELGTPEGQWVPQSEPLHPINKISSTEPCTGDRSVFCQMEVLDRYCSIPGYHRLCCVSCIKKASGPNPGPDPGPTSLPPFSTPGSPLPGPQDPADAAEPPGKPTGSEDHQHGRATQLPGALDTSSPGTQHPFAPETPIPGASWSISPTTPGGLPWGWTQTPTPVPEDKGQPGEDLRHPGTSLPAASPVT"
seq_hADAMTS15 = "MLLLGILTLAFAGRTAGGSEPEREVVVPIRLDPDINGRRYYWRGPEDSGDQGLIFQITAFQEDFYLHLTPDAQFLAPAFSTEHLGVPLQGLTGGSSDLRRCFYSGDVNAEPDSFAAVSLCGGLRGAFGYRGAEYVISPLPNASAPAAQRNSQGAHLLQRRGVPGGPSGDPTSRCGVASGWNPAILRALDPYKPRRAGFGESRSRRRSGRAKRFVSIPRYVETLVVADESMVKFHGADLEHYLLTLLATAARLYRHPSILNPINIVVVKVLLLRDRDSGPKVTGNAALTLRNFCAWQKKLNKVSDKHPEYWDTAILFTRQDLCGATTCDTLGMADVGTMCDPKRSCSVIEDDGLPSAFTTAHELGHVFNMPHDNVKVCEEVFGKLRANHMMSPTLIQIDRANPWSACSAAIITDFLDSGHGDCLLDQPSKPISLPEDLPGASYTLSQQCELAFGVGSKPCPYMQYCTKLWCTGKAKGQMVCQTRHFPWADGTSCGEGKLCLKGACVERHNLNKHRVDGSWAKWDPYGPCSRTCGGGVQLARRQCTNPTPANGGKYCEGVRVKYRSCNLEPCPSSASGKSFREEQCEAFNGYNHSTNRLTLAVAWVPKYSGVSPRDKCKLICRANGTGYFYVLAPKVVDGTLCSPDSTSVCVQGKCIKAGCDGNLGSKKRFDKCGVCGGDNKSCKKVTGLFTKPMHGYNFVVAIPAGASSIDIRQRGYKGLIGDDNYLALKNSQGKYLLNGHFVVSAVERDLVVKGSLLRYSGTGTAVESLQASRPILEPLTVEVLSVGKMTPPRVRYSFYLPKEPREDKSSHPKDPRGPSVLHNSVLSLSNQVEQPDDRPPARWVAGSWGPCSASCGSGLQKRAVDCRGSAGQRTVPACDAAHRPVETQACGEPCPTWELSAWSPCSKSCGRGFQRRSLKCVGHGGRLLARDQCNLHRKPQELDFCVLRPC"
seq_hADAMTS16 = "MKPRARGWRGLAALWMLLAQVAEQAPACAMGPAAAAPGSPSVPRPPPPAERPGWMEKGEYDLVSAYEVDHRGDYVSHEIMHHQRRRRAVPVSEVESLHLRLKGSRHDFHMDLRTSSSLVAPGFIVQTLGKTGTKSVQTLPPEDFCFYQGSLRSHRNSSVALSTCQGLSGMIRTEEADYFLRPLPSHLSWKLGRAAQGSSPSHVLYKRSTEPHAPGASEVLVTSRTWELAHQPLHSSDLRLGLPQKQHFCGRRKKYMPQPPKEDLFILPDEYKSCLRHKRSLLRSHRNEELNVETLVVVDKKMMQNHGHENITTYVLTILNMVSALFKDGTIGGNINIAIVGLILLEDEQPGLVISHHADHTLSSFCQWQSGLMGKDGTRHDHAILLTGLDICSWKNEPCDTLGFAPISGMCSKYRSCTINEDTGLGLAFTIAHESGHNFGMIHDGEGNMCKKSEGNIMSPTLAGRNGVFSWSPCSRQYLHKFLSTAQAICLADQPKPVKEYKYPEKLPGELYDANTQCKWQFGEKAKLCMLDFKKDICKALWCHRIGRKCETKFMPAAEGTICGHDMWCRGGQCVKYGDEGPKPTHGHWSDWSSWSPCSRTCGGGVSHRSRLCTNPKPSHGGKFCEGSTRTLKLCNSQKCPRDSVDFRAAQCAEHNSRRFRGRHYKWKPYTQVEDQDLCKLYCIAEGFDFFFSLSNKVKDGTPCSEDSRNVCIDGICERVGCDNVLGSDAVEDVCGVCNGNNSACTIHRGLYTKHHHTNQYYHMVTIPSGARSIRIYEMNVSTSYISVRNALRRYYLNGHWTVDWPGRYKFSGTTFDYRRSYNEPENLIATGPTNETLIVELLFQGRNPGVAWEYSMPRLGTEKQPPAQPSYTWAIVRSECSVSCGGGQMTVREGCYRDLKFQVNMSFCNPKTRPVTGLVPCKVSACPPSWSVGNWSACSRTCGGGAQSRPVQCTRRVHYDSEPVPASLCPQPAPSSRQACNSQSCPPAWSAGPWAECSHTCGKGWRKRAVACKSTNPSARAQLLPDAVCTSEPKPRMHEACLLQRCHKPKKLQWLVSAWSQCSVTCERGTQKRFLKCAEKYVSGKYRELASKKCSHLPKPSLELERACAPLPCPRHPPFAAAGPSRGSWFASPWSQCTASCGGGVQTRSVQCLAGGRPASGCLLHQKPSASLACNTHFCPIAEKKDAFCKDYFHWCYLVPQHGMCSHKFYGKQCCKTCSKSNL"
seq_hADAMTS17 = "MCDGALLPPLVLPVLLLLVWGLDPGTAVGDAAADVEVVLPWRVRPDDVHLPPLPAAPGPRRRRRPRTPPAAPRARPGERALLLHLPAFGRDLYLQLRRDLRFLSRGFEVEEAGAARRRGRPAELCFYSGRVLGHPGSLVSLSACGAAGGLVGLIQLGQEQVLIQPLNNSQGPFSGREHLIRRKWSLTPSPSAEAQRPEQLCKVLTEKKKPTWGRPSRDWRERRNAIRLTSEHTVETLVVADADMVQYHGAEAAQRFILTVMNMVYNMFQHQSLGIKINIQVTKLVLLRQRPAKLSIGHHGERSLESFCHWQNEEYGGARYLGNNQVPGGKDDPPLVDAAVFVTRTDFCVHKDEPCDTVGIAYLGGVCSAKRKCVLAEDNGLNLAFTIAHELGHNLGMNHDDDHSSCAGRSHIMSGEWVKGRNPSDLSWSSCSRDDLENFLKSKVSTCLLVTDPRSQHTVRLPHKLPGMHYSANEQCQILFGMNATFCRNMEHLMCAGLWCLVEGDTSCKTKLDPPLDGTECGADKWCRAGECVSKTPIPEHVDGDWSPWGAWSMCSRTCGTGARFRQRKCDNPPPGPGGTHCPGASVEHAVCENLPCPKGLPSFRDQQCQAHDRLSPKKKGLLTAVVVDDKPCELYCSPLGKESPLLVADRVLDGTPCGPYETDLCVHGKCQKIGCDGIIGSAAKEDRCGVCSGDGKTCHLVKGDFSHARGTALKDSGKGSINSDWKIELPGEFQIAGTTVRYVRRGLWEKISAKGPTKLPLHLMVLLFHDQDYGIHYEYTVPVNRTAENQSEPEKPQDSLFIWTHSGWEGCSVQCGGGERRTIVSCTRIVNKTTTLVNDSDCPQASRPEPQVRRCNLHPCQSRWVAGPWSPCSATCEKGFQHREVTCVYQLQNGTHVATRPLYCPGPRPAAVQSCEGQDCLSIWEASEWSQCSASCGKGVWKRTVACTNSQGKCDASTRPRAEEACEDYSGCYEWKTGDWSTCSSTCGKGLQSRVVQCMHKVTGRHGSECPALSKPAPYRQCYQEVCNDRINANTITSPRLAALTYKCTRDQWTVYCRVIREKNLCQDMRWYQRCCQTCRDFYANKMRQPPPNS"
seq_hADAMTS18 = "MECALLLACAFPAAGSGPPRGLAGLGRVAKALQLCCLCCASVAAALASDSSSGASGLNDDYVFVTPVEVDSAGSYISHDILHNGRKKRSAQNARSSLHYRFSAFGQELHLELKPSAILSSHFIVQVLGKDGASETQKPEVQQCFYQGFIRNDSSSSVAVSTCAGLSGLIRTRKNEFLISPLPQLLAQEHNYSSPAGHHPHVLYKRTAEEKIQRYRGYPGSGRNYPGYSPSHIPHASQSRETEYHHRRLQKQHFCGRRKKYAPKPPTEDTYLRFDEYGSSGRPRRSAGKSQKGLNVETLVVADKKMVEKHGKGNVTTYILTVMNMVSGLFKDGTIGSDINVVVVSLILLEQEPGGLLINHHADQSLNSFCQWQSALIGKNGKRHDHAILLTGFDICSWKNEPCDTLGFAPISGMCSKYRSCTINEDTGLGLAFTIAHESGHNFGMIHDGEGNPCRKAEGNIMSPTLTGNNGVFSWSSCSRQYLKKFLSTPQAGCLVDEPKQAGQYKYPDKLPGQIYDADTQCKWQFGAKAKLCSLGFVKDICKSLWCHRVGHRCETKFMPAAEGTVCGLSMWCRQGQCVKFGELGPRPIHGQWSAWSKWSECSRTCGGGVKFQERHCNNPKPQYGGLFCPGSSRIYQLCNINPCNENSLDFRAQQCAEYNSKPFRGWFYQWKPYTKVEEEDRCKLYCKAENFEFFFAMSGKVKDGTPCSPNKNDVCIDGVCELVGCDHELGSKAVSDACGVCKGDNSTCKFYKGLYLNQHKANEYYPVVLIPAGARSIEIQELQVSSSYLAVRSLSQKYYLTGGWSIDWPGEFPFAGTTFEYQRSFNRPERLYAPGPTNETLVFEILMQGKNPGIAWKYALPKVMNGTPPATKRPAYTWSIVQSECSVSCGGGYINVKAICLRDQNTQVNSSFCSAKTKPVTEPKICNAFSCPAYWMPGEWSTCSKACAGGQQSRKIQCVQKKPFQKEEAVLHSLCPVSTPTQVQACNSHACPPQWSLGPWSQCSKTCGRGVRKRELLCKGSAAETLPESQCTSLPRPELQEGCVLGRCPKNSRLQWVASSWSECSATCGLGVRKREMKCSEKGFQGKLITFPERRCRNIKKPNLDLEETCNRRACPAHPVYNMVAGWYSLPWQQCTVTCGGGVQTRSVHCVQQGRPSSSCLLHQKPPVLRACNTNFCPAPEKREDPSCVDFFNWCHLVPQHGVCNHKFYGKQCCKSCTRKI"
seq_hADAMTS19 = "MGKNREMRLTHICCCCLLYQLGFLSNGIVSELQFAPDREEWEVVFPALWRREPVDPAGGSGGSADPGWVRGVGGGGSARAQAAGSSREVRSVAPVPLEEPVEGRSESRLRPPPPSEGEEDEELESQELPRGSSGAAALSPGAPASWQPPPPPQPPPSPPPAQHAEPDGDEVLLRIPAFSRDLYLLLRRDGRFLAPRFAVEQRPNPGPGPTGAASAPQPPAPPDAGCFYTGAVLRHPGSLASFSTCGGGLMGFIQLNEDFIFIEPLNDTMAITGHPHRVYRQKRSMEEKVTEKSALHSHYCGIISDKGRPRSRKIAESGRGKRYSYKLPQEYNIETVVVADPAMVSYHGADAARRFILTILNMVFNLFQHKSLSVQVNLRVIKLILLHETPPELYIGHHGEKMLESFCKWQHEEFGKKNDIHLEMSTNWGEDMTSVDAAILITRKDFCVHKDEPCDTVGIAYLSGMCSEKRKCIIAEDNGLNLAFTIAHEMGHNMGINHDNDHPSCADGLHIMSGEWIKGQNLGDVSWSRCSKEDLERFLRSKASNCLLQTNPQSVNSVMVPSKLPGMTYTADEQCQILFGPLASFCQEMQHVICTGLWCKVEGEKECRTKLDPPMDGTDCDLGKWCKAGECTSRTSAPEHLAGEWSLWSPCSRTCSAGISSRERKCPGLDSEARDCNGPRKQYRICENPPCPAGLPGFRDWQCQAYSVRTSSPKHILQWQAVLDEEKPCALFCSPVGKEQPILLSEKVMDGTSCGYQGLDICANGRCQKVGCDGLLGSLAREDHCGVCNGNGKSCKIIKGDFNHTRGAGYVEVLVIPAGARRIKVVEEKPAHSYLALRDAGKQSINSDWKIEHSGAFNLAGTTVHYVRRGLWEKISAKGPTTAPLHLLVLLFQDQNYGLHYEYTIPSDPLPENQSSKAPEPLFMWTHTSWEDCDATCGGGERKTTVSCTKIMSKNISIVDNEKCKYLTKPEPQIRKCNEQPCQTRWMMTEWTPCSRTCGKGMQSRQVACTQQLSNGTLIRARERDCIGPKPASAQRCEGQDCMTVWEAGVWSECSVKCGKGIRHRTVRCTNPRKKCVLSTRPREAEDCEDYSKCYVWRMGDWSKCSITCGKGMQSRVIQCMHKITGRHGNECFSSEKPAAYRPCHLQPCNEKINVNTITSPRLAALTFKCLGDQWPVYCRVIREKNLCQDMRWYQRCCETCRDFYAQKLQQKS"
seq_hADAMTS20 = "MWVAKWLTGLLYHLSLFITRSWEVDFHPRQEALVRTLTSYEVVIPERVNEFGEVFPQSHHFSRQKRSSEALEPMPFRTHYRFTAYGQLFQLNLTADASFLAAGYTEVHLGTPERGAWESDAGPSDLRHCFYRGQVNSQEDYKAVVSLCGGLTGTFKGQNGEYFLEPIMKADGNEYEDGHNKPHLIYRQDLNNSFLQTLKYCSVSESQIKETSLPFHTYSNMNEDLNVMKERVLGHTSKNVPLKDERRHSRKKRLISYPRYIEIMVTADAKVVSAHGSNLQNYILTLMSIVATIYKDPSIGNLIHIVVVKLVMIHREEEGPVINFDGATTLKNFCSWQQTQNDLDDVHPSHHDTAVLITREDICSSKEKCNMLGLSYLGTICDPLQSCFINEEKGLISAFTIAHELGHTLGVQHDDNPRCKEMKVTKYHVMAPALSFHMSPWSWSNCSRKYVTEFLDTGYGECLLDKPDEEIYNLPSELPGSRYDGNKQCELAFGPGSQMCPHINICMHLWCTSTEKLHKGCFTQHVPPADGTDCGPGMHCRHGLCVNKETETRPVNGEWGPWEPYSSCSRTCGGGIESATRRCNRPEPRNGGNYCVGRRMKFRSCNTDSCPKGTQDFREKQCSDFNGKHLDISGIPSNVRWLPRYSGIGTKDRCKLYCQVAGTNYFYLLKDMVEDGTPCGTETHDICVQGQCMAAGCDHVLNSSAKIDKCGVCGGDNSSCKTITGVFNSSHYGYNVVVKIPAGATNVDIRQYSYSGQPDDSYLALSDAEGNFLFNGNFLLSTSKKEINVQGTRTVIEYSGSNNAVERINSTNRQEKEILIEVLCVGNLYNPDVHYSFNIPLEERSDMFTWDPYGPWEGCTKMCQGLQRRNITCIHKSDHSVVSDKECDHLPLPSFVTQSCNTDCELRWHVIGKSECSSQCGQGYRTLDIHCMKYSIHEGQTVQVDDHYCGDQLKPPTQELCHGNCVFTRWHYSEWSQCSRSCGGGERSRESYCMNNFGHRLADNECQELSRVTRENCNEFSCPSWAASEWSECLVTCGKGTKQRQVWCQLNVDHLSDGFCNSSTKPESLSPCELHTCASWQVGPWGPCTTTCGHGYQMRDVKCVNELASAVLEDTECHEASRPSDRQSCVLTPCSFISKLETALLPTVLIKKMAQWRHGSWTPCSVSCGRGTQARYVSCRDALDRIADESYCAHLPRPAEIWDCFTPCGEWQAGDWSPCSASCGHGKTTRQVLCMNYHQPIDENYCDPEVRPLMEQECSLAACPPAHSHFPSSPVQPSYYLSTNLPLTQKLEDNENQVVHPSVRGNQWRTGPWGSCSSSCSGGLQHRAVVCQDENGQSASYCDAASKPPELQQCGPGPCPQWNYGNWGECSQTCGGGIKSRLVICQFPNGQILEDHNCEIVNKPPSVIQCHMHACPADVSWHQEPWTSCSASCGKGRKYREVFCIDQFQRKLEDTNCSQVQKPPTHKACRSVRCPSWKANSWNECSVTCGSGVQQRDVYCRLKGVGQVVEEMCDQSTRPCSQRRCWSQDCVQHKGMERGRLNCSTSCERKDSHQRMECTDNQIRQVNEIVYNSSTISLTSKNCRNPPCNYIVVTADSSQCANNCGFSYRQRITYCTEIPSTKKHKLHRLRPIVYQECPVVPSSQVYQCINSCLHLATWKVGKWSKCSVTCGIGIMKRQVKCITKHGLSSDLCLNHLKPGAQKKCYANDCKSFTTCKEIQVKNHIRKDGDYYLNIKGRIIKIYCADMYLENPKEYLTLVQGEENFSEVYGFRLKNPYQCPFNGSRREDCECDNGHLAAGYTVFSKIRIDLTSMQIKTTDLLFSKTIFGNAVPFATAGDCYSAFRCPQGQFSINLSGTGMKISSTAKWLTQGSYTSVSIRRSEDGTRFFGKCGGYCGKCLPHMTTGLPIQVI"

sequences_dict = {
    "hMMP1": seq_hMMP1,"hMMP2": seq_hMMP2,"hMMP3": seq_hMMP3, "hMMP7": seq_hMMP7, "hMMP8": seq_hMMP8,"hMMP9": seq_hMMP9,
    "hMMP10": seq_hMMP10,"hMMP11": seq_hMMP11,"mMMP12": seq_mMMP12,"hMMP12": seq_hMMP12,"hMMP13": seq_hMMP13,"MT_hMMP14": seq_MT_hMMP14,
    "MT_hMMP15": seq_MT_hMMP15,"MT_hMMP16": seq_MT_hMMP16,"MT_hMMP17": seq_MT_hMMP17,"hMMP19": seq_hMMP19,"hMMP20": seq_hMMP20,
    "hMMP21": seq_hMMP21,"hMMP23": seq_hMMP23,"MT_hMMP24": seq_MT_hMMP24,"hMMP25": seq_hMMP25,"hMMP26": seq_hMMP26,"hMMP27": seq_hMMP27,
    "hMMP28": seq_hMMP28,"HSA": seq_HSA,"BSA": seq_BSA,"MSA": seq_MSA,"Chymotrypsin": seq_Chymotrypsin,"Trypsin": seq_Trypsin,
    "IL1": seq_IL1,"hADAMTS1": seq_hADAMTS1,"hADAMTS2": seq_hADAMTS2,"hADAMTS3": seq_hADAMTS3,"hADAMTS4": seq_hADAMTS4,"hADAMTS5": seq_hADAMTS5,
    "hADAMTS6": seq_hADAMTS6,"hADAMTS7": seq_hADAMTS7,"hADAMTS9": seq_hADAMTS9,"hADAMTS10": seq_hADAMTS10,"hADAMTS12": seq_hADAMTS12,
    "hADAMTS13": seq_hADAMTS13,"hADAMTS14": seq_hADAMTS14,"hADAMTS15": seq_hADAMTS15,"hADAMTS16": seq_hADAMTS16,"hADAMTS17": seq_hADAMTS17,
    "hADAMTS18": seq_hADAMTS18,"hADAMTS19": seq_hADAMTS19,"hADAMTS20": seq_hADAMTS20}

prodomain_bounds = {
    "hMMP1":   (90, 100, 105),"hMMP7":   (85, 95, 100),"hMMP10":  (89, 99, 104), "hMMP11":  (78, 88, 93),"MT_hMMP14": (91, 101, 106),
    "MT_hMMP15": (109, 119, 124),"MT_hMMP16": (99, 109, 114),"MT_hMMP17": (108, 118, 123),"hMMP19":  (83, 93, 98),"hMMP20":  (98, 108, 113),
    "hMMP21":  (115, 125, 130),"hMMP23":  (None, None, None),"hMMP24":  (137, 147, 152),"hMMP25":  (88, 98, 103),"hMMP26":  (80, 90, 95),   # PHC
    "hMMP27":  (89, 99, 104),"hMMP28":  (89, 99, 104),}

prodomain_ends = {
    "hMMP12": 109,"hMMP3": 99, "hMMP8": 100, "hMMP9": 93, "hMMP12": 105, "mMMP12": 109, "hMMP13":103, "hMMP14": 111,}

# Global variables
results_list = []
soustractor_sheets = []
soustractor_files = ""
last_df_soustraction = None

# =============================================================================
# 2. Classes
# =============================================================================

@dataclass
class AnalysisConfig:
    tolerance: float = 0.1
    max_missed_cleavages: int = 100
    marking_types: Dict[str, float] = field(default_factory=lambda: {
        "AmbCHCA": 304.095792,
        "AhxCHCA": 284.126092,
        "Aucun": 0.0
    })

class SequenceService:
    def __init__(self, sequences: Dict[str, str]):
        self.sequences = sequences

    def get_sequence(self, protein_name: str) -> Optional[str]:
        return self.sequences.get(protein_name)
    
class PeptideAnalysisService:
    def __init__(self, config: AnalysisConfig, sequence_service: SequenceService):
        self.config = config
        self.sequence_service = sequence_service
        self.mass_calculator = MassCalculator()
        self.peptide_finder = PeptideFinder(sequence_service.sequences, self.mass_calculator)

    def find_peptides(self, protein_name: str, mass_target: float):
        seq = self.sequence_service.get_sequence(protein_name)
        if not seq:
            return []
        return self.peptide_finder.find_by_mass(mass_target, self.config.tolerance)

class MassCalculator:
    def __init__(self):
        self.aa_masses = amino_acids_masses

    @lru_cache(maxsize=10000)
    def calculate_mass(self, sequence):
        return sum(self.aa_masses.get(aa, 0) for aa in sequence)

mass_calculator = MassCalculator() 

class Tooltip(object):
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tipwindow = None
        widget.bind("<Enter>", self.show_tip)
        widget.bind("<Leave>", self.hide_tip)

    def show_tip(self, event=None):
        if self.tipwindow or not self.text:
            return
        x, y, cx, cy = self.widget.bbox("insert")
        x = x + self.widget.winfo_rootx() + 25
        y = y + self.widget.winfo_rooty() + 25
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=self.text, justify='left',
                         background="#ffffe0", relief='solid', borderwidth=1,
                         font=("tahoma", "10", "normal"))
        label.pack(ipadx=1)
    def hide_tip(self, event=None):
        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()

class PeptideFinder:
    def __init__(self, sequences_dict, mass_calculator):
        self.sequences = sequences_dict
        self.mass_calculator = mass_calculator
        self.peptide_index = defaultdict(list)
        self._precompute_peptides()
    
    def _precompute_peptides(self):
        for protein, sequence in self.sequences.items():
            for length in range(1, 21):
                for start in range(len(sequence) - length + 1):
                    peptide = sequence[start:start + length]
                    mass = self.mass_calculator.calculate_mass(peptide)
                    adjusted_mass = mass + 17.999565 
                    self.peptide_index[round(adjusted_mass, 3)].append({
                        'sequence': peptide,
                        'protein': protein,
                        'start': start,
                        'end': start + length - 1,
                        'mass': mass,
                        'adjusted_mass': adjusted_mass
                    })

    def find_by_mass(self, mass, tolerance=0.5):
        results = []
        min_key = int((mass - tolerance) * 1000)
        max_key = int((mass + tolerance) * 1000)
        for m in range(min_key, max_key + 1):
            key = m / 1000
            for peptide in self.peptide_index.get(key, []):
                if abs(peptide['adjusted_mass'] - mass) <= tolerance:
                    results.append(peptide)
        return results

peptide_finder = PeptideFinder(sequences_dict, mass_calculator)

# Central configuration and services
config = AnalysisConfig()
sequence_service = SequenceService(sequences_dict)
analysis_service = PeptideAnalysisService(config, sequence_service)

# =============================================================================
# 2. MALDI peak analysis functions 
# =============================================================================

def adjust_target_mass(target_mass, labeling):
    if labeling == "AmbCHCA":
        return target_mass - 304.095792
    elif labeling == "AhxCHCA":
        return target_mass - 284.126092
    else:
        return target_mass

def verify_sequence(seq):
    if seq.endswith('K') and seq.count('K') < 2:
        return False
    return True

def calculate_custom_missed_cleavages(seq):
    if chymotrypsin_var.get() and not trypsin_var.get():
        cleavage_sites = ['F', 'Y', 'W', 'M', 'L','H']
        offset = 1
    elif trypsin_var.get() and not chymotrypsin_var.get():
        cleavage_sites = ['R', 'K']
        offset = 2
    elif chymotrypsin_var.get() and trypsin_var.get():
        cleavage_sites = ['F', 'Y', 'W', 'M', 'L','H', 'R', 'K']
        offset = 2
    else:
        cleavage_sites = []
        offset = 0

    count = sum(seq.count(res) for res in cleavage_sites)
    return count - offset

def find_peptides(sequence, target_mass, allowed_deviation):
    results = []
    for length in range(1, 21):
        for i in range(len(sequence) - length + 1):
            sous_seq = sequence[i:i+length]
            mass = mass_calculator.calculate_mass(sous_seq)
            mass_adjusted = mass + 17.999565
            if abs(mass_adjusted - target_mass) < allowed_deviation:
                results.append((sous_seq, mass_adjusted, mass, i, i+length-1))
    return results

def clean_mass_entry(event=None):
    text = mass_entry.get()
    cleaned_text = re.sub(r"[^\d\., ]", "", text)  
    if text != cleaned_text:
        pos = mass_entry.index(tk.INSERT)
        diff = len(text) - len(cleaned_text)
        mass_entry.delete(0, tk.END)
        mass_entry.insert(0, cleaned_text)
        try:
            new_pos = max(0, pos - diff)
            mass_entry.icursor(new_pos)
        except Exception:
            mass_entry.icursor(tk.END)
    mass_entry.update_idletasks()

def clean_mass_entry_after_paste(event=None):
    mass_entry.after_idle(clean_mass_entry)

def domain_status(protein, peptide_start):
    end = prodomain_ends.get(protein)
    if end is None:
        return "no"
    if peptide_start <= end:
        return "yes"
    else:
        return "no"
    
def show_results():
    global results_list
    try:
        start_time = time.time()
        results_list = []
        no_matches = []
        tested_combinations = 0
        target_mass_input = mass_entry.get().strip().replace(',', '.')
        target_mass_list = [float(m.strip()) - 1 for m in target_mass_input.split()]
        label = label_var.get()
        config.tolerance = float(ecart_entry.get().strip().replace(',', '.'))
        config.max_missed_cleavages = int(miss_max_entry.get().strip())
        text_results.delete(1.0, tk.END)
        selected_mMMPs = [seq for seq, var in sequences_vars.items() if var.get()]
        if custom_seq_var.get() and custom_seq_value.get():
            selected_mMMPs.append("CustomSeq")
        wanted_amino_acids = []
        if chymotrypsin_var.get():
            wanted_amino_acids.extend(['F', 'Y', 'L', 'W', 'M', 'H'])
        if trypsin_var.get():
            wanted_amino_acids.extend(['K', 'R'])
        nb_possibilites_testees = 0
        for target_mass in target_mass_list:
            pic_ajuste = round(target_mass + 1, 3)
            adjusted_wanted_mass = adjust_target_mass(target_mass, label)
            match_trouve = False
            for mmp in selected_mMMPs:
                tested_combinations += 1
                if mmp == "CustomSeq":
                    sequence_to_compare = custom_seq_value.get().strip().upper()
                    resultats = find_peptides(sequence_to_compare, adjusted_wanted_mass, config.tolerance)
                else:
                    resultats = [
                        (d['sequence'], d['adjusted_mass'], d['mass'], d['start'], d['end'])
                        for d in analysis_service.find_peptides(mmp, adjusted_wanted_mass)
                        if d['protein'] == mmp
                    ]
                    sequence_to_compare = globals()[f"seq_{mmp}"]
                for seq, adjusted_masses, mass, start_pos, end_pos in resultats:
                    nb_possibilites_testees += 1
                    if seq[-1] not in wanted_amino_acids:
                        continue
                    if label in ("AmbCHCA", "AhxCHCA") and 'K' not in seq:
                        continue
                    if not verify_sequence(seq):
                        continue
                    miss_clivage = calculate_custom_missed_cleavages(seq)
                    if miss_clivage > config.max_missed_cleavages:
                        continue
                    if not include_prodomain_var.get():
                        if domain_status(mmp, start_pos+1) == "yes":
                            continue
                    if label == "AmbCHCA":
                        labeled_mass = adjusted_masses + 304.095792
                    elif label == "AhxCHCA":
                        labeled_mass = adjusted_masses + 284.126092
                    else:
                        labeled_mass = adjusted_masses
                    ecart = round(labeled_mass - target_mass, 2)
                    acide_amine_precedent = sequence_to_compare[start_pos-1] if (start_pos > 0 and start_pos <= len(sequence_to_compare)) else None
                    pic_ajuste_resultat = round(target_mass + 1, 2)
                    if acide_amine_precedent and acide_amine_precedent in wanted_amino_acids:
                        results_list.append([pic_ajuste_resultat, mmp, f"({acide_amine_precedent}){seq}",
                                            f"{start_pos+1}-{end_pos+1}", round(labeled_mass, 2), ecart, miss_clivage])
                        match_trouve = True
                    elif acide_amine_precedent is None:
                        results_list.append([pic_ajuste_resultat, mmp, f"({'None'}){seq}",
                                            f"{start_pos+1}-{end_pos+1}", round(labeled_mass, 2), ecart, miss_clivage])
                        match_trouve = True
            if not match_trouve:
                pic_ajuste = round(target_mass + 1, 2)
                no_matches.append([pic_ajuste, "no match", "no sequence", "N/A", "N/A", "N/A", "N/A"])

        # Dataframe creation
        df = pd.DataFrame(results_list, columns=["MALDI peaks", "Protein", "Sequence", "Position", "Masses", "Gap", "MissCleavage"])
        def get_statut(row):
            pos_str = str(row["Position"])
            try:
                peptide_start = int(pos_str.split('-')[0])
                return domain_status(row["Protein"], peptide_start)
            except Exception:
                return "non"
        df["Pro-Domain?"] = df.apply(get_statut, axis=1)
        # Overlapping peptides detection and merging
        def intervals_overlap_and_merge(pos_list):
            intervals = []
            for seq, pos in pos_list:
                start, end = map(int, pos.split('-'))
                intervals.append({'start': start, 'end': end, 'seqs': [seq]})
            merged = []
            for interval in sorted(intervals, key=lambda x: x['start']):
                if not merged or merged[-1]['end'] < interval['start']:
                    merged.append(interval)
                else:
                    merged[-1]['end'] = max(merged[-1]['end'], interval['end'])
                    merged[-1]['seqs'].extend(interval['seqs'])
            return merged
        peptides_by_enzyme = df.groupby("Protein")[["Sequence", "Position"]].apply(lambda x: list(zip(x["Sequence"], x["Position"])))
        peptides_duplicated_stats = []
        for enzyme, peptides in peptides_by_enzyme.items():
            merged = intervals_overlap_and_merge(peptides)
            for group in merged:
                if len(group['seqs']) > 1:
                    seqs = group['seqs']
                    start, end = group['start'], group['end']
                    seq_overlap = None
                    for seq, pos in peptides:
                        s, e = map(int, pos.split('-'))
                        if s <= start and e >= end:
                            if seq_overlap is None or len(seq) > len(seq_overlap):
                                seq_overlap = seq
                    if seq_overlap is None:
                        seq_overlap = seqs[0]
                    peptides_duplicated_stats.append(
                        f"{enzyme}: {seq_overlap} ({start}-{end}) | {len(seqs)} peptides"
                    )

        if peptides_duplicated_stats:
            # Sort by number of overlapping peptides descending
            sorted_overlaps = sorted(peptides_duplicated_stats, key=lambda x: int(x.split('|')[-1].split()[0]), reverse=True)
            dupliques_str = "Overlapping peptides: " + " || ".join(sorted_overlaps)
        else:
            dupliques_str = "No overlapping peptides."

        elapsed_time = time.time() - start_time
        enzyme_counts = Counter(df["Protein"])
        # Sort by number of enzyme occurence descending
        sorted_enzymes = sorted(enzyme_counts.items(), key=lambda x: x[1], reverse=True)
        enzyme_stats = ', '.join([f"{k}: {v}" for k, v in sorted_enzymes])

        # Display results in the text area
        text_results.insert(tk.END,
            f"Stats : {nb_possibilites_testees} tested combinations | "
            f"Analysis time : {elapsed_time:.2f} s\n"
        )
        text_results.insert(tk.END,
            f"Occurrences enzymes : {enzyme_stats}\n\n"
        )
        text_results.insert(tk.END, f"{dupliques_str}\n\n")
        for index, row in df.iterrows():
            text_results.insert(tk.END,
                f"MALDI peak: {row['MALDI peaks']}, Protein: {row['Protein']}, Sequence: {row['Sequence']}, "
                f"Position: {row['Position']}, Masses: {row['Masses']}, Gap: {row['Gap']}, "
                f"MissCleavage: {row['MissCleavage']}, Pro-Domain?: {row['Pro-Domain?']}\n")
        if no_matches:
            text_results.insert(tk.END, "\n--- No match for the following peaks ---\n")
            for result in no_matches:
                text_results.insert(tk.END,
                    f"MALDI peak: {result[0]} : No match\n")

        if results_list or no_matches:
            export_button.config(state=tk.NORMAL)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def to_subscript(num):
    sub_map = str.maketrans("0123456789", "₀₁₂₃₄₅₆₇₈₉")
    return str(num).translate(sub_map)

def export_results(results):
    try:
        if not results:
            messagebox.showwarning("No result", "No results to export.")
            return

        file = filedialog.asksaveasfilename(defaultextension=".xlsx", 
                                               filetypes=[("Excel files", "*.xlsx")])
        if file:
            # Dataframe creation
            df = pd.DataFrame(results, columns=["MALDI peaks", "Protein", "Sequence", "Position", "Masses", "Gap", "MissCleavage"])
            df["Pro-Domain?"] = df.apply(lambda row: domain_status(row["Protein"], int(str(row["Position"]).split('-')[0])), axis=1)

            # Enzyme / Occurrence table
            enzyme_counts = Counter(df["Protein"])
            sorted_enzymes = sorted(enzyme_counts.items(), key=lambda x: x[1], reverse=True)
            df_stats_occ = pd.DataFrame(sorted_enzymes, columns=["Enzyme", "Occurrence"])

            # Enzyme / Overlapping Sequences / Positions / Nb peptides table
            def intervals_overlap_and_merge(pos_list):
                intervals = []
                for seq, pos, mass in pos_list:
                    start, end = map(int, pos.split('-'))
                    intervals.append({'start': start, 'end': end, 'seqs': [seq], 'positions': [pos], 'masses': [mass]})
                merged = []
                for interval in sorted(intervals, key=lambda x: x['start']):
                    if not merged or merged[-1]['end'] < interval['start']:
                        merged.append(interval)
                    else:
                        merged[-1]['end'] = max(merged[-1]['end'], interval['end'])
                        merged[-1]['seqs'].extend(interval['seqs'])
                        merged[-1]['positions'].extend(interval['positions'])
                        merged[-1]['masses'].extend(interval['masses'])
                return merged

            # Mass inclusion in the overlapping peptides table
            peptides_by_enzyme = df.groupby("Protein")[["Sequence", "Position", "Masses"]].apply(
                lambda x: list(zip(x["Sequence"], x["Position"], x["Masses"]))
            )
            overlapping_data = []
            for enzyme, peptides in peptides_by_enzyme.items():
                merged = intervals_overlap_and_merge(peptides)
                for group in merged:
                    if len(group['seqs']) > 1:
                        seqs_str = "\n".join(group['seqs'])
                        positions_str = "\n".join(group['positions'])
                        masses_str = "\n".join(str(m) for m in group['masses'])
                        overlapping_data.append([enzyme, seqs_str, positions_str, masses_str, len(group['seqs'])])
            df_overlapping = pd.DataFrame(
                overlapping_data,
                columns=["Enzyme", "Overlapping Sequences", "Positions", "Masses", "Nb peptides"]
            )
            df_overlapping = df_overlapping.sort_values(by="Nb peptides", ascending=False).reset_index(drop=True)

            # Excel export with formatting
            with pd.ExcelWriter(file, engine="xlsxwriter") as writer:
                df.to_excel(writer, index=False, sheet_name="Results")
                df_stats_occ.to_excel(writer, index=False, startcol=len(df.columns) + 2, sheet_name="Results")
                df_overlapping.to_excel(writer, index=False, startcol=len(df.columns) + 6, sheet_name="Results")

                workbook  = writer.book
                worksheet = writer.sheets["Results"]
                wrap_format = workbook.add_format({'text_wrap': True, 'align': 'left', 'valign': 'vcenter'})  

                for i, col in enumerate(df.columns):
                    max_len = max(
                        df[col].astype(str).map(len).max(),
                        len(str(col))
                    )
                    worksheet.set_column(i, i, max(15, min(max_len + 2, 80)), wrap_format)  

                for row in range(1, len(df) + 1):
                    n_lines = max(df.iloc[row-1].astype(str).map(lambda x: x.count('\n') + 1))
                    worksheet.set_row(row, 15 * n_lines)

                overlap_startcol = len(df.columns) + 6
                for i, col in enumerate(df_overlapping.columns):
                    max_len = max(
                        df_overlapping[col].astype(str).map(len).max(),
                        len(str(col))
                    )
                    worksheet.set_column(overlap_startcol + i, overlap_startcol + i, max(15, min(max_len + 2, 80)), wrap_format)

                for row in range(1, len(df_overlapping) + 1):
                    seq_cell = df_overlapping.iloc[row-1, df_overlapping.columns.get_loc("Overlapping Sequences")]
                    masses_cell = df_overlapping.iloc[row-1, df_overlapping.columns.get_loc("Masses")]
                    n_lines = max(str(seq_cell).count('\n') + 1, str(masses_cell).count('\n') + 1)
                    worksheet.set_row(row, 15 * n_lines)

            messagebox.showinfo("Successful Export", f"Results exported to {file}")
        else:
            messagebox.showwarning("No File Selected", "You must choose a file for export.")
    except Exception as e:
        messagebox.showerror("Export Error", f"An error occurred while exporting results: {e}")
        print(f"Export error: {e}")

# =============================================================================
# 3. Soustractor functions
# =============================================================================

def read_txt_file(file_path):
    try:
        df = pd.read_csv(file_path, sep=r'\s+', header=None, names=["m/z", "Intens."])
        return df
    except Exception as e:
        messagebox.showerror("Error", f"could not read TXT file: {e}")
        return None

def find_local_maxima(df):
    maxima = []
    for i in range(1, len(df) - 1):
        if df["Intens."].iloc[i] > df["Intens."].iloc[i - 1] and df["Intens."].iloc[i] > df["Intens."].iloc[i + 1]:
            maxima.append(i)
    return maxima

def group_and_sum(df, maxima, tol):
    grouped = []

    for max_idx in maxima:
        group = [df.iloc[max_idx]]
        left_idx = max_idx - 1
        right_idx = max_idx + 1

        while left_idx >= 0 and df["Intens."].iloc[left_idx] < df["Intens."].iloc[left_idx + 1]:
            group.insert(0, df.iloc[left_idx])
            left_idx -= 1

        while right_idx < len(df) and df["Intens."].iloc[right_idx] < df["Intens."].iloc[right_idx - 1]:
            group.append(df.iloc[right_idx])
            right_idx += 1

        mz_max = max(group, key=lambda x: x["Intens."])["m/z"]
        intens_sum = sum([row["Intens."] for row in group])
        grouped.append({"m/z": mz_max, "Intens.": intens_sum})

    result_df = pd.DataFrame(grouped)
    return result_df.sort_values(by="Intens.", ascending=False)

def add_isotope_column(df):
    df = df.sort_values(by="m/z").reset_index(drop=True)
    df["Isotope"] = ""
    isotope_counter = 0

    for i in range(len(df)):
        if i == 0 or df["m/z"].iloc[i] - df["m/z"].iloc[i - 1] > 1.2:
            isotope_counter = 0
        else:
            isotope_counter += 1
        df.at[i, "Isotope"] = f"A+{isotope_counter}" if isotope_counter > 0 else "A"

    return df

def process_files(input_file_A, input_file_E, tol, loading_window, progress_bar, loading_label):
    ascii_steps = [
           "[0%] Loading TXT files...",
            "[10%] Subtracting intensities...",
            "[20%] Finding local maxima...",
            "[30%] Grouping & summing peaks...",
            "[60%] Adding isotope column...",
            "[70%] Finalizing table...",
            "[80%] Writing Excel output...",
            "[100%] Opening Excel file...",
    ]
    try:
        # 1. Loading TXT files
        loading_label.config(text=ascii_steps[0])
        progress_bar['value'] = 5
        loading_window.update_idletasks()
        df_A = read_txt_file(input_file_A)
        if df_A is None:
            root.after(0, loading_window.destroy)
            return

        df_E = read_txt_file(input_file_E)
        if df_E is None:
            root.after(0, loading_window.destroy)
            return

        # 2. Subtracting intensities
        loading_label.config(text=ascii_steps[1])
        progress_bar['value'] = 10
        loading_window.update_idletasks()
        if len(df_A) != len(df_E):
            root.after(0, lambda: messagebox.showerror("Error", "Files A and E must have the same number of lines."))
            root.after(0, loading_window.destroy)
            return

        df_result = df_A.copy()
        df_result["Intens."] = df_E["Intens."] - df_A["Intens."]
        global dernier_df_soustraction
        dernier_df_soustraction = df_result.copy()

        def show_plot():
            plot_spectrum(df_result)

        plot_button = tk.Button(loading_window, text="Show Spectrum", command=show_plot)
        plot_button.pack(pady=5)

        # 3. Finding local maxima
        loading_label.config(text=ascii_steps[2])
        progress_bar['value'] = 20
        loading_window.update_idletasks()
        maxima = find_local_maxima(df_result)

        # 4. Grouping & summing peaks
        loading_label.config(text=ascii_steps[3])
        progress_bar['value'] = 30
        loading_window.update_idletasks()
        df_result = group_and_sum(df_result, maxima, tol)

        # 5. Adding isotope column
        loading_label.config(text=ascii_steps[4])
        progress_bar['value'] = 60
        loading_window.update_idletasks()
        top_50 = df_result.head(50).copy()
        top_50 = add_isotope_column(top_50)

        # 6. Finalizing table
        loading_label.config(text=ascii_steps[5])
        progress_bar['value'] = 70
        loading_window.update_idletasks()
        top_50 = top_50.sort_values(by="m/z").reset_index(drop=True)
        top_50 = top_50[["Isotope", "m/z", "Intens."]]
        isotopes_A = top_50[top_50["Isotope"] == "A"][["m/z", "Intens."]]

        # 7. Writing Excel output
        loading_label.config(text=ascii_steps[6])
        progress_bar['value'] = 80
        loading_window.update_idletasks()
        output_file = filedialog.asksaveasfilename(
            title="Save Excel Output File",
            defaultextension=".xlsx",
            filetypes=[("Excel Files", "*.xlsx")]
        )
        if not output_file:
            root.after(0, lambda: messagebox.showerror("Error", "No output file selected."))
            root.after(0, loading_window.destroy)
            return

        try:
            with pd.ExcelWriter(output_file) as writer:
                df_result.to_excel(writer, index=False, header=True, sheet_name="Results")
                global dernier_df_result
                dernier_df_result = df_result.copy()
                top_50.to_excel(writer, index=False, header=True, startcol=4, sheet_name="Results")
                isotopes_A.to_excel(writer, index=False, header=True, startcol=9, sheet_name="Results")
        except Exception as e:
            messagebox.showerror("Error", f"Error writing file: {e}")
            loading_window.destroy()
            return

        # 8. Opening Excel file
        loading_label.config(text=ascii_steps[7])
        progress_bar['value'] = 100
        loading_window.update_idletasks()
        root.after(0, lambda: os.startfile(output_file))
        root.after(0, loading_window.destroy)
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")
        plot_spectrum(df_result)
        loading_window.destroy()

def extract_mz_soustractor():
    global soustractor_files
    try:
        input_file_A = filedialog.askopenfilename(title="Select TXT file for CHCA", filetypes=[("TXT file", "*.txt")])
        input_file_E = filedialog.askopenfilename(title="Select TXT file for CHCE", filetypes=[("TXT file", "*.txt")])
        tol = 0.1  # tolerance in m/z for peak grouping

        if not input_file_A or not input_file_E:
            messagebox.showerror("Error", "Please select both TXT files.")
            return

        # Create a loading window
        loading_window = tk.Toplevel(root)
        loading_window.title("Loading...")

        # ASCII animation frames
        ascii_frames = [
            "[0%] Loading TXT files...",
            "[10%] Subtracting intensities...",
            "[20%] Finding local maxima...",
            "[30%] Grouping & summing peaks...",
            "[50%] Adding isotope column...",
            "[60%] Finalizing table...",
            "[70%] Writing Excel output...",
            "[100%] Opening Excel file...",
        ]
        loading_label = tk.Label(loading_window, font=("Consolas", 32), text=ascii_frames[0])
        loading_label.pack(pady=30, padx=30)
        progress_bar = ttk.Progressbar(loading_window, orient="horizontal", length=400, mode="determinate")
        progress_bar.pack(pady=10)
        progress_bar['value'] = 0

        # Start the processing in a separate thread
        threading.Thread(target=process_files, args=(input_file_A, input_file_E, tol, loading_window, progress_bar, loading_label)).start()

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def plot_spectrum(df, title="Subtracted Spectrum"):
    plt.figure(figsize=(10, 5))
    plt.plot(df["m/z"], df["Intens."], color='blue', label="Spectrum")
    plt.xlabel("m/z")
    plt.ylabel("Intensity")
    plt.title(title)
    plt.tight_layout()

    # Find local maxima and minimas
    maxima = []
    minima = []
    for i in range(1, len(df) - 1):
        if df["Intens."].iloc[i] > df["Intens."].iloc[i - 1] and df["Intens."].iloc[i] > df["Intens."].iloc[i + 1]:
            maxima.append(i)
        if df["Intens."].iloc[i] < df["Intens."].iloc[i - 1] and df["Intens."].iloc[i] < df["Intens."].iloc[i + 1]:
            minima.append(i)

    seuil_pos = 0.1 * df["Intens."].max()
    seuil_neg = -0.3 * abs(df["Intens."].max())

    # Show m/z value above each maximum, prioritizing the most intense and spacing labels
    labeled_mz = []
    maxima_10_sorted = sorted(maxima, key=lambda i: df["Intens."].iloc[i], reverse=True)
    for i in maxima_10_sorted:
        mz = df["m/z"].iloc[i]
        intens = df["Intens."].iloc[i]
        if intens >= seuil_pos:
            # Do not show the label if a label already exists between mz-1 and mz+3
            if all(not (lmz - 1 <= mz <= lmz + 3) for lmz in labeled_mz):
                plt.annotate(f"{mz:.2f}", (mz, intens), textcoords="offset points", xytext=(0,8), ha='center', fontsize=8, color='darkred', rotation=90)
                labeled_mz.append(mz)

    # Show m/z value below each minimum if intensity < -30% of max
    for i in minima:
        mz = df["m/z"].iloc[i]
        intens = df["Intens."].iloc[i]
        if intens <= seuil_neg:
            if all(not (lmz - 1 <= mz <= lmz + 3) for lmz in labeled_mz):
                plt.annotate(f"{mz:.2f}", (mz, intens), textcoords="offset points", xytext=(0,-30), ha='center', fontsize=7, color='gray', rotation=90)
                labeled_mz.append(mz)
    plt.legend()
    plt.show()

def plot_positive_only(df, title="Spectrum (positive values only)"):
    df_pos = df[df["Intens."] > 0]
    plt.figure(figsize=(10, 5))
    plt.plot(df_pos["m/z"], df_pos["Intens."], color='green', label="Positive Spectrum")
    plt.xlabel("m/z")
    plt.ylabel("Intensity")
    plt.title(title)
    plt.tight_layout()

        # Finding local maxima
    maxima = []
    for i in range(1, len(df) - 1):
        if df["Intens."].iloc[i] > df["Intens."].iloc[i - 1] and df["Intens."].iloc[i] > df["Intens."].iloc[i + 1]:
            maxima.append(i)

    # Only consider maxima with intensity > 10% of max intensity
    seuil = 0.1 * df["Intens."].max()
    maxima_10 = [i for i in maxima if df["Intens."].iloc[i] >= seuil]

    # Show m/z value above each maximum, prioritizing the most intense and spacing labels
    labeled_mz = []
    maxima_10_sorted = sorted(maxima_10, key=lambda i: df["Intens."].iloc[i], reverse=True)
    for i in maxima_10_sorted:
        mz = df["m/z"].iloc[i]
        intens = df["Intens."].iloc[i]
        if intens >= seuil:
            # Do not show the label if a label already exists between mz-1 and mz+3
            if all(not (lmz - 1 <= mz <= lmz + 3) for lmz in labeled_mz):
                plt.annotate(f"{mz:.2f}", (mz, intens), textcoords="offset points", xytext=(0,8), ha='center', fontsize=8, color='darkred', rotation=90)
                labeled_mz.append(mz)
    plt.legend()
    plt.show()

def plot_last_result():
    if dernier_df_soustraction is not None:
        plot_spectrum(dernier_df_soustraction, title="Substracted spectra")
        plot_positive_only(dernier_df_soustraction, title="Spectrum (positive values only)")
        maxima = find_local_maxima(dernier_df_soustraction)
        df_grouped = group_and_sum(dernier_df_soustraction, maxima, tol=0.1)
    else:
        messagebox.showwarning("No Result", "No analysis has been performed yet.")

# =============================================================================
# 4. Extract m/z from Excel function
# =============================================================================

def extract_column_m_z():
    try:
        excel_file = filedialog.askopenfilename(title="Select Excel file", filetypes=[("Excel Files", "*.xlsx")])
        if not excel_file:
            messagebox.showerror("Error", "Please select an Excel file.")
            return

            # Header=None to read without headers initially
        df = pd.read_excel(excel_file)
        if "m/z" in df.columns:
            col_values = df["m/z"].dropna().tolist()
        else:
            # if no "m/z" column, ask user to select a sheet and read from there
            df = pd.read_excel(excel_file, header=None)
            if df.shape[0] < 3:
                messagebox.showerror("Error", "The Excel file does not contain enough rows.")
                return
            col_values = df.iloc[2:, 0].dropna().tolist()  

        # Filter and format values as floats with 3 decimal places
        col_values_float = []
        for v in col_values:
            try:
                col_values_float.append(f"{float(v):.3f}")
            except Exception:
                continue

        # Upsdate the mass_entry field
        mass_entry.delete(0, tk.END)
        mass_entry.insert(0, ' '.join(col_values_float))

        messagebox.showinfo("Success", "All m/z values have been extracted and copied to the 'MALDI Peaks' field.")
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def choose_Sheet(file):
    try:
        xls = pd.ExcelFile(file)
        sheet = simpledialog.askstring("Select Sheet", "Choose a sheet from:\n" + "\n".join(xls.sheet_names))

        if sheet not in xls.sheet_names:
            messagebox.showerror("Error", "The selected sheet does not exist.")
            return None

        return sheet
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while selecting the sheet: {e}")
        return None

# =============================================================================
# 5. MS/MS Analysis functions 
# =============================================================================

def extract_precursor_mass_from_sheet(sheet_df):
    # precursor mass is in the first cell of the sheet, format like "1234.56.LIFT"
    cell = str(sheet_df.iloc[0, 0])
    match = re.search(r'([\d\.]+)\.LIFT', cell)
    if match:
        return float(match.group(1))
    return None

def read_all_sheets_precursor_masses(excel_path):
    xls = pd.ExcelFile(excel_path)
    results = []
    for sheet_name in xls.sheet_names:
        df = pd.read_excel(xls, sheet_name=sheet_name, header=None)
        precursor_mass = extract_precursor_mass_from_sheet(df)
        if precursor_mass is not None:
            # Data starts from row 4, columns 1 (m/z) and 3 (Intensity)
            msms_df = df.iloc[3:, [0, 2]].copy()
            msms_df.columns = ["m/z", "Intens."]
            msms_df = msms_df.apply(pd.to_numeric, errors='coerce')
            msms_df = msms_df.dropna()
            results.append((sheet_name, precursor_mass, msms_df))
    return results

def filter_peptides_by_mass(peptides, precursor_mass, tolerance):
    # peptides: list of dicts or tuples with 'adjusted_mass' or mass
    return [pep for pep in peptides if abs(pep['adjusted_mass'] + 1 - precursor_mass) <= tolerance]

def analysis_spectra_vs_peptides(excel_path, peptides, tolerance=1.0, frag_tol=1):
    sheets = read_all_sheets_precursor_masses(excel_path)
    report = []

    # Get the selected labeling type from the interface
    label_type = label_var.get()
    
    for sheet_name, precursor_mass, msms_df in sheets:
        peptides_match = filter_peptides_by_mass(peptides, precursor_mass, tolerance)
        
        for pep in peptides_match:
            seq = pep['sequence']

            # Generate labeled variants
            variants = generate_labeled_msms_sequence(seq, label_type)

            for variant in variants:
                sequence = variant['sequence']
                label_pos = variant['label_pos']
                label_type_variant = variant['label_type']

                # Generate theoretical fragments with labeling
                fragments = generate_theoretical_fragments_with_marking(
                    sequence, label_pos, label_type_variant
                )
                
                peaks = extract_peaks(msms_df, intensity_threshold=0.05)
                matches = match_theoretical_to_experimental(fragments, peaks, tol=frag_tol)
                score = ion_match_score(fragments, matches)
                
                # Label the sequence accordingly
                if label_pos is not None:
                    sequence_desc = f"{sequence} (K{label_pos+1}*-{label_type_variant})"
                else:
                    sequence_desc = f"{sequence} (unlabeled)"
                
                unique_matches = sorted(
                    { (m['type'], m['mz_obs']) : m for m in matches }.values(),
                    key=lambda m: m['mz_obs']
                )
                score = ion_match_score(fragments, unique_matches)
                report.append({
                    "Spectrum": sheet_name,
                    "Precursor": precursor_mass,
                    "Sequence": sequence_desc,
                    "Enzyme": pep.get('protein', ''),
                    "Position": pep.get('position', ''),
                    "Theoretical Mass": pep['adjusted_mass'],
                    "Score": score,
                    "Nb fragments": len(fragments),
                    "Nb matches": len(unique_matches),
                    "Matched_fragments": "\n".join(
                        format_fragment_type(m['type'], m['num'], sequence) +
                        f" (obs:{m['mz_obs']:.2f}, Δ={m['mz_obs'] - m['mz_theo']:+.2f})"
                        for m in unique_matches
                    )
                })
    df = pd.DataFrame(report)
    df = df.drop_duplicates()
    return df


def run_analysis_msms():
    excel_path = filedialog.askopenfilename(title="Select Excel MS/MS file", filetypes=[("Excel Files", "*.xlsx")])
    if not excel_path:
        return

    # Ask for tolerance
    tol_str = simpledialog.askstring("MS/MS Tolerance", "Enter the tolerance value for MS/MS analysis (e.g. 0.5):")
    if tol_str is None:
        return
    try:
        tolerance = float(tol_str.replace(',', '.'))
    except Exception:
        messagebox.showerror("Error", "Invalid tolerance value.")
        return

    # Get all peptides found in the main search (results_list)
    peptides = []
    for row in results_list:
        peptides.append({
            "sequence": row[2].split(')')[-1],  # remove the (X) if present
            "adjusted_mass": float(row[4]),
            "protein": row[1],                  # Protein column
            "position": row[3]                  # Position column
        })

    report = analysis_spectra_vs_peptides(excel_path, peptides, tolerance=tolerance, frag_tol=0.5)
    # Display or export the report
    report_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel Files", "*.xlsx")])
    if report_path:
        report.to_excel(report_path, index=False)

        # Add centering, line breaks, and auto height for the 'Matched_fragments' column
        with pd.ExcelWriter(report_path, engine="xlsxwriter") as writer:
            report.to_excel(writer, index=False)
            workbook  = writer.book
            worksheet = writer.sheets["Sheet1"]  # or "Results" depending on the sheet name
            wrap_format = workbook.add_format({'text_wrap': True, 'align': 'left', 'valign': 'vcenter'})  # vertical centering only

            # Auto width for all columns
            for i, col in enumerate(report.columns):
                max_len = max(
                    report[col].astype(str).map(len).max(),
                    len(str(col))
                )
                worksheet.set_column(i, i, max(15, min(max_len + 2, 80)), wrap_format)  # min width 15, max 80

            # Adjust row height for 'Matched_fragments' column
            col_idx = report.columns.get_loc("Matched_fragments")
            for row in range(1, len(report) + 1):
                cell_value = report.iloc[row-1, col_idx]
                n_lines = str(cell_value).count('\n') + 1
                worksheet.set_row(row, 15 * n_lines)

        messagebox.showinfo("Success", f"MS/MS report exported: {report_path}")
    else:
        messagebox.showinfo("Info", "No report file selected.")

def generate_labeled_msms_sequence(sequence, label_type):

    if label_type == "None":
        return [{'sequence': sequence, 'label_pos': None, 'label_type': 'None'}]

    positions_K = [i for i, aa in enumerate(sequence) if aa == "K"]
    if not positions_K:
        return [{'sequence': sequence, 'label_pos': None, 'label_type': 'None'}]

    variants = []
    for pos in positions_K:
        variants.append({
            'sequence': sequence,
            'label_pos': pos,
            'label_type': label_type
        })
    
    return variants

def format_fragment_type(type_str, num, sequence=None):
    if type_str == "i":
        if sequence and isinstance(num, int) and 1 <= num <= len(sequence):
            return f"{sequence[num-1]}i"
        else:
            return f"i"
    # Internal fragments
    if type_str.startswith("internal"):
        # num est un tuple (start, end)
        suffix_match = re.match(r"(internal)([+-].+|-[A-Z0-9]+|)", type_str)
        suffix = ""
        if suffix_match:
            suffix = suffix_match.group(2)
        if isinstance(num, tuple):
            if num[0] == num[1]:  # only one AA
                if sequence and 1 <= num[0] <= len(sequence):
                    aa = sequence[num[0]-1]
                    return f"{aa}{suffix}"
                else:
                    return f"{num[0]}{suffix}"
            else:
                if sequence and 1 <= num[0] <= num[1] <= len(sequence):
                    aa_seq = sequence[num[0]-1:num[1]]
                    return aa_seq + suffix
                else:
                    return f"{num[0]}-{num[1]}"
        else:
            # only one AA (rare case, but we also handle the suffix)
            if sequence and 1 <= num <= len(sequence):
                return f"{sequence[num-1]}{suffix}"
            else:
                return f"{num}{suffix}"
    else:
        match = re.match(r"([a-z]+)([+-].+)?", type_str)
        if match:
            main = match.group(1)
            suffix = match.group(2) or ""
            return f"{main}{to_subscript(num)}{suffix}"
        else:
            num_str = to_subscript(num)
            return f"{type_str}{num_str}"

def generate_theoretical_fragments_with_marking(sequence, label_pos=None, label_type="None"):
    fragments = []
    loss_H2O = 18.010565
    loss_NH3 = 17.026549
    loss_CO = 28.010565
    add_H2O = 18.010565
    aa_loss_H2O = "STED"
    aa_loss_NH3 = "RQNK"
    aa_add_H2O = "RHK"

    # labels
    mass_K_normal = amino_acids_masses["K"]
    mass_K_AhxCHCA = 412.21106
    mass_K_AmbCHCA = 432.17976
    
    def get_aa_mass(aa, position):
        if aa == "K" and label_pos is not None and position == label_pos:
            if label_type == "AhxCHCA":
                return mass_K_AhxCHCA
            elif label_type == "AmbCHCA":
                return mass_K_AmbCHCA
        return amino_acids_masses.get(aa, 0)
    
    # immonium ions
    for i, aa in enumerate(sequence):
        if aa in immonium_ions_masses:
            for mass in immonium_ions_masses[aa]:
                fragments.append({
                    'type': 'i',
                    'num': i+1,  
                    'mz': mass
                })

    # a and b ions
    for i in range(1, len(sequence)):
        frag_seq = sequence[:i]
        mass_b = sum(get_aa_mass(aa, pos) for pos, aa in enumerate(frag_seq))
        mz_b = round(mass_b + mass_proton, 4)
        fragments.append({'type': 'b', 'num': i, 'mz': mz_b})
        mz_a = round(mass_b - loss_CO + mass_proton , 4)
        fragments.append({'type': 'a', 'num': i, 'mz': mz_a})
        
        # Losses and additions for b ions
        if any(aa in frag_seq for aa in aa_loss_H2O):
            fragments.append({'type': 'b-H₂O', 'num': i, 'mz': round(mz_b - loss_H2O, 4)})
        if any(aa in frag_seq for aa in aa_loss_NH3):
            fragments.append({'type': 'b-NH₃', 'num': i, 'mz': round(mz_b - loss_NH3, 4)})
        if any(aa in frag_seq for aa in aa_add_H2O):
            fragments.append({'type': 'b+H₂O', 'num': i, 'mz': round(mz_b + add_H2O, 4)})

    # y ions
    for i in range(1, len(sequence)):
        frag_seq = sequence[-i:]
        start_pos = len(sequence) - i
        mass_y = sum(get_aa_mass(aa, start_pos + pos) for pos, aa in enumerate(frag_seq)) + 2*mass_H + mass_O
        mz_y = round(mass_y + mass_proton, 4)
        fragments.append({'type': 'y', 'num': i, 'mz': mz_y})
        
        if any(aa in frag_seq for aa in aa_loss_H2O):
            fragments.append({'type': 'y-H₂O', 'num': i, 'mz': round(mz_y - loss_H2O, 4)})
        if any(aa in frag_seq for aa in aa_loss_NH3):
            fragments.append({'type': 'y-NH₃', 'num': i, 'mz': round(mz_y - loss_NH3, 4)})
        if any(aa in frag_seq for aa in aa_add_H2O):
            fragments.append({'type': 'y+H₂O', 'num': i, 'mz': round(mz_y + add_H2O, 4)})

    # Internal fragments
    for start in range(1, len(sequence)-1):
        for end in range(start+1, len(sequence)):
            frag_seq = sequence[start:end]
            length = end - start
            mass_int = sum(get_aa_mass(aa, start + pos) for pos, aa in enumerate(frag_seq)) 
            mz_int = round(mass_int + mass_proton, 4)
            if length == 1:
                aa = frag_seq[0]
                fragments.append({'type': 'internal', 'num': (start+1, end), 'mz': mz_int})
                # Do not generate internal-CO for only one AA (immonium ion already exists)
                if aa in aa_loss_H2O:
                    fragments.append({'type': 'internal-H₂O', 'num': (start+1, end), 'mz': round(mz_int - loss_H2O, 4)})
                if aa in aa_loss_NH3:
                    fragments.append({'type': 'internal-NH₃', 'num': (start+1, end), 'mz': round(mz_int - loss_NH3, 4)})
                if aa in aa_add_H2O:
                    fragments.append({'type': 'internal+H₂O', 'num': (start+1, end), 'mz': round(mz_int + add_H2O, 4)})
            else:
                fragments.append({'type': 'internal', 'num': (start+1, end), 'mz': mz_int})
                fragments.append({'type': 'internal-CO', 'num': (start+1, end), 'mz': round(mz_int - loss_CO, 4)})
                if any(aa in frag_seq for aa in aa_loss_H2O):
                    fragments.append({'type': 'internal-H₂O', 'num': (start+1, end), 'mz': round(mz_int - loss_H2O, 4)})
                if any(aa in frag_seq for aa in aa_loss_NH3):
                    fragments.append({'type': 'internal-NH₃', 'num': (start+1, end), 'mz': round(mz_int - loss_NH3, 4)})
                if any(aa in frag_seq for aa in aa_add_H2O):
                    fragments.append({'type': 'internal+H₂O', 'num': (start+1, end), 'mz': round(mz_int + add_H2O, 4)})

    return fragments

def extract_peaks(df, intensity_threshold=None):
    return df[["m/z", "Intens."]].reset_index(drop=True)

def match_theoretical_to_experimental(theoretical, experimental, tol=1):
    matches = []
    seen = set()
    for frag in theoretical:
        key = (frag['type'], frag['num'], frag['mz'])
        if key in seen:
            continue  # Ignore duplicate fragments
        seen.add(key)
        mz_theo = frag['mz']
        found = experimental[(experimental["m/z"] >= mz_theo - tol) & (experimental["m/z"] <= mz_theo + tol)]
        if not found.empty:
            # Take the closest peak (in m/z)
            row = found.iloc[(found["m/z"] - mz_theo).abs().argmin()]
            matches.append({
                'type': frag['type'],
                'num': frag['num'],
                'mz_theo': mz_theo,
                'mz_obs': row["m/z"],
                'intensity': row["Intens."]
            })
    return matches

def ion_match_score(theoretical, matches):
    if not theoretical:
        return 0
    return round(100 * len(matches) / len(theoretical), 1)

# =============================================================================
# 4. Graphical Interface
# =============================================================================

root = tk.Tk()
root.title("EnzymatorV1.00 - by Ugo PASCO")
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()
root.geometry(f"{int(screen_width*0.9)}x{int(screen_height*0.9)}")
root.resizable(True, True)
# root.state('zoomed')  # Uncomment to force full screen on Windows

# --- Main frame ---
main_frame = tk.Frame(root)
main_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

# --- Entry field for masses with horizontal scrollbar ---
frame_mass = tk.LabelFrame(main_frame, text="MALDI peak(s) (space-separated)")
frame_mass.pack(fill=tk.X, padx=5, pady=5)
mass_entry = tk.Entry(frame_mass, width=70)
scrollbar_x = tk.Scrollbar(frame_mass, orient="horizontal", command=mass_entry.xview)
scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
mass_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
mass_entry.config(xscrollcommand=scrollbar_x.set)
mass_entry.bind("<KeyRelease>", clean_mass_entry)
mass_entry.bind("<FocusOut>", clean_mass_entry)
mass_entry.bind("<<Paste>>", clean_mass_entry) # Automatic cleaning on each keystroke

# --- Buttons to extract and choose sheets ---
frame_buttons = tk.Frame(main_frame)
frame_buttons.pack(fill=tk.X, padx=5, pady=5)
extract_soustractor_button = tk.Button(frame_buttons, text="SoustractorV2", command=extract_mz_soustractor)
extract_soustractor_button.pack(side=tk.LEFT, padx=5, pady=5)
Tooltip(extract_soustractor_button, "Soustractor: Subtracts CHCA and CHCE spectrum by using text files from FlexAnalysis: File> Export> Mass Spectrum.")
plot_last_button = tk.Button(frame_buttons, text="Show spectrum", command=plot_last_result)
plot_last_button.pack(side=tk.LEFT, padx=5, pady=5)
Tooltip(plot_last_button, "Show substracted spectrum, you must run soustractor prior to use.")
extract_column_j_button = tk.Button(frame_buttons, text="Extract", command=extract_column_m_z)
extract_column_j_button.pack(side=tk.LEFT, padx=5, pady=5)
btn_msms = tk.Button(frame_buttons, text="MS/MS Analysis", command=run_analysis_msms)
btn_msms.pack(side=tk.LEFT, padx=5, pady=5)
Tooltip(btn_msms, "MS/MS Analysis: search masses before use, then use excel files from FlexAnalysis: File> Export >Mass List To Excel to run the analysis.")

# --- Digestion enzyme(s) options ---
frame_digestion = tk.LabelFrame(main_frame, text="Digestion enzyme(s)")
frame_digestion.pack(fill=tk.X, padx=5, pady=5)
chymotrypsin_var = tk.BooleanVar()
trypsin_var = tk.BooleanVar()
tk.Checkbutton(frame_digestion, text="Chymotrypsin", variable=chymotrypsin_var).pack(side=tk.LEFT, padx=5, pady=5)
tk.Checkbutton(frame_digestion, text="Trypsin", variable=trypsin_var).pack(side=tk.LEFT, padx=5, pady=5)

sequences_vars = {
    "hMMP1": tk.BooleanVar(),"hMMP2": tk.BooleanVar(),"hMMP3": tk.BooleanVar(), "hMMP7": tk.BooleanVar(),"hMMP8": tk.BooleanVar(),
    "hMMP9": tk.BooleanVar(),"hMMP10": tk.BooleanVar(),"hMMP11": tk.BooleanVar(),"mMMP12": tk.BooleanVar(),"hMMP12": tk.BooleanVar(),
    "hMMP13": tk.BooleanVar(),"MT_hMMP14": tk.BooleanVar(),"MT_hMMP15": tk.BooleanVar(),"MT_hMMP16": tk.BooleanVar(),"MT_hMMP17": tk.BooleanVar(),
    "hMMP19": tk.BooleanVar(),"hMMP20": tk.BooleanVar(),"hMMP21": tk.BooleanVar(),"hMMP23": tk.BooleanVar(),"MT_hMMP24": tk.BooleanVar(),
    "hMMP25": tk.BooleanVar(),"hMMP26": tk.BooleanVar(),"hMMP27": tk.BooleanVar(),"hMMP28": tk.BooleanVar(),"HSA": tk.BooleanVar(),
    "BSA": tk.BooleanVar(),"MSA": tk.BooleanVar(),"Chymotrypsin": tk.BooleanVar(),"Trypsin": tk.BooleanVar(),"IL1": tk.BooleanVar(),
    "hADAMTS1": tk.BooleanVar(),"hADAMTS2": tk.BooleanVar(),"hADAMTS3": tk.BooleanVar(),"hADAMTS4": tk.BooleanVar(),"hADAMTS5": tk.BooleanVar(),"hADAMTS6": tk.BooleanVar(),
    "hADAMTS7": tk.BooleanVar(),"hADAMTS9": tk.BooleanVar(),"hADAMTS10": tk.BooleanVar(),"hADAMTS12": tk.BooleanVar(),"hADAMTS13": tk.BooleanVar(),
    "hADAMTS14": tk.BooleanVar(),"hADAMTS15": tk.BooleanVar(),"hADAMTS16": tk.BooleanVar(),"hADAMTS17": tk.BooleanVar(),"hADAMTS18": tk.BooleanVar(),
    "hADAMTS19": tk.BooleanVar(),"hADAMTS20": tk.BooleanVar()}

# --- Sequence selection ---
custom_seq_var = tk.BooleanVar()
custom_seq_value = tk.StringVar()
frame_sequences = tk.LabelFrame(main_frame, text="Choose sequence(s) to compare")
frame_sequences.pack(fill=tk.X, padx=5, pady=5)
frame_seq_horiz = tk.Frame(frame_sequences)
frame_seq_horiz.pack(fill=tk.X, expand=True)

def place_checkbuttons(frame, seqs, var_dict, n_col=2):
    for i, seq in enumerate(seqs):
        row, col = divmod(i, n_col)
        tk.Checkbutton(frame, text=seq, variable=var_dict[seq]).grid(row=row, column=col, sticky="w", padx=2, pady=2)

mmp_important = ["hMMP1", "hMMP2", "hMMP3", "hMMP7", "hMMP8", "hMMP9", "hMMP12", "hMMP13"]
standards = ["Chymotrypsin", "HSA", "MSA", "Trypsin", "BSA", "IL1"]
adamts = [seq for seq in sequences_vars if seq.startswith("hADAMTS") or seq.startswith("mADAMTS")]
autres = [seq for seq in sequences_vars if seq not in mmp_important + standards + adamts]

# Bloc 1 : Main OA implicated MMPs
frame_mmp_important = tk.LabelFrame(frame_seq_horiz, text="OA implicated MMPs")
frame_mmp_important.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
place_checkbuttons(frame_mmp_important, mmp_important, sequences_vars, n_col=3)

# Bloc 2 : Contaminants
frame_standard = tk.LabelFrame(frame_seq_horiz, text="Contaminants")
frame_standard.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
place_checkbuttons(frame_standard, standards, sequences_vars, n_col=3)

# Bloc 3 : ADAMTS
frame_adamts = tk.LabelFrame(frame_seq_horiz, text="ADAMTS")
frame_adamts.grid(row=0, column=2, sticky="nsew", padx=5, pady=5)
place_checkbuttons(frame_adamts, adamts, sequences_vars, n_col=3)

# Bloc 4 : Other MMPs
frame_mmp_autres = tk.LabelFrame(frame_seq_horiz, text="Other MMPs")
frame_mmp_autres.grid(row=0, column=3, sticky="nsew", padx=5, pady=5)
place_checkbuttons(frame_mmp_autres, autres, sequences_vars, n_col=3)
# Bloc 5 : Custom sequence and select/deselect all
frame_options = tk.Frame(frame_seq_horiz)
frame_options.grid(row=0, column=4, sticky="nsew", padx=5, pady=5)
def open_custom_seq():
    seq = simpledialog.askstring("Custom Sequence", "Enter your sequence (AA letters):")
    if seq:
        custom_seq_value.set(seq)
        custom_seq_var.set(True)
    else:
        custom_seq_var.set(False)
btn_custom_seq = tk.Button(frame_options, text="Custom Sequence", command=open_custom_seq)
btn_custom_seq.pack(padx=2, pady=2, fill=tk.X)
tk.Checkbutton(frame_options, text="Use", variable=custom_seq_var).pack(padx=2, pady=2, fill=tk.X)
def select_all():
    # Check if all are already selected
    all_selected = all(var.get() for var in sequences_vars.values())
    for var in sequences_vars.values():
        var.set(not all_selected)
btn_tout_sel = tk.Button(frame_options, text="Select/Deselect All", command=select_all)
btn_tout_sel.pack(padx=2, pady=2, fill=tk.X)

# Adjust column sizes to fill available space
for i in range(5):
    frame_seq_horiz.grid_columnconfigure(i, weight=1)

# --- sub-parameters ---
frame_params = tk.Frame(main_frame)
frame_params.pack(fill=tk.X, padx=5, pady=5)
tk.Label(frame_params, text="Allowed Deviation").pack(side=tk.LEFT, padx=5, pady=5)
ecart_entry = tk.Entry(frame_params, width=10)
ecart_entry.insert(0, "0.5")  # Default value
ecart_entry.pack(side=tk.LEFT, padx=5, pady=5)
tk.Label(frame_params, text="Allowed MissCleavages").pack(side=tk.LEFT, padx=5, pady=5)
miss_max_entry = tk.Entry(frame_params, width=10)
miss_max_entry.insert(0, "3")  # Default value
miss_max_entry.pack(side=tk.LEFT, padx=5, pady=5)
include_prodomain_var = tk.BooleanVar(value=True)
# --- pro-domain ---
tk.Checkbutton(frame_params, text="Include pro-domain fragments", variable=include_prodomain_var).pack(side=tk.LEFT, padx=5, pady=5)

# --- labeling ---
frame_label = tk.LabelFrame(main_frame, text="Label type (AmbCHCA / AhxCHCA / Aucun)")
frame_label.pack(fill=tk.X, padx=5, pady=5)
label_var = tk.StringVar(value="AhxCHCA")
tk.Radiobutton(frame_label, text="AmbCHCA", variable=label_var, value="AmbCHCA").pack(side=tk.LEFT, padx=5, pady=5)
tk.Radiobutton(frame_label, text="AhxCHCA", variable=label_var, value="AhxCHCA").pack(side=tk.LEFT, padx=5, pady=5)
tk.Radiobutton(frame_label, text="Aucun", variable=label_var, value="Aucun").pack(side=tk.LEFT, padx=5, pady=5)


# --- Research button ---
search_button = tk.Button(main_frame, text="Search", command=show_results)
search_button.pack(padx=5, pady=5)

# --- Text zone ---
frame_resultats = tk.LabelFrame(main_frame, text="Results")
frame_resultats.pack(fill=tk.BOTH, padx=5, pady=5, expand=True)
scrollbar = tk.Scrollbar(frame_resultats)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
text_results = tk.Text(frame_resultats, height=15, width=100, yscrollcommand=scrollbar.set, wrap="none")
text_results.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
scrollbar.config(command=text_results.yview)

# --- Export results button ---
export_button = tk.Button(frame_resultats, text="Export Results", state=tk.DISABLED, command=lambda: export_results(results_list))
export_button.pack(padx=5, pady=5)

# --- GUI launch ---
root.mainloop()

